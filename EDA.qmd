# 探索的データ分析 {#sec-exploratory-data-analysis}

```{r}
#| echo: false

source("_common.R")
```

## はじめに

本章では、可視化と変換を使って、統計学者が探索的データ分析 (略してEDA) と呼ぶ、データを探索する組織立った方法を示します。
EDAは反復サイクルです。
あなたは、

1.  データについて質問を生成します。

2.  データを可視化、変換、モデル化して、回答を探します。

3.  分かったことを使って質問を精錬させる、もしくは、新しい質問を生成する。

EDAは厳格な規則集がある正式な過程ではありません。
EDAは何よりもまず、心の持ち様なのです。
EDAの初期段階では思いついた全てのアイディアを気ままに調査すべきです。
いくつかのアイディアは広がり、またいくつかのアイディアは行き詰まります。
探索を続けるうちに、2、3の特に実りある洞察を行き着き、最終的には報告書を書き上げて他者に伝達することになります。

EDAはどんなデータ分析でも重要な部分です。た
とえ、研究の第一義的な質問が盆に載せて手渡されたとしても、データ品質を調べる必要が常にある以上、EDAは欠かせません。
データ・クリーニングはEDAの一つの応用に過ぎません。デ
ータが期待に沿うものか否かの質問にあたります。
データ・クリーニングを行うには、可視化、変換、モデル化といったEDAの全ての道具を持ち出す必要があります。

### 準備するもの

本章では、dplyrとggplot2について学習したことを組み合わせて、質問を尋ね、データを使って回答、そしてまた新しい質問を尋ねることを繰り返します。

```{r}
#| label: setup
#| message: false

library(tidyverse)
```

## 質問

> "決まりきった統計上の質問などない。あるのは疑わしい統計の決まりきった手順だけだ。" --- Sir David Cox

> "間違った質問への常に精密にできる正確な回答よりも、正しい質問への大まかでたいてい曖昧な回答の方がずっと良い。" --- John Tukey

EDAでのゴールはデータの理解を深めることです。
最も簡単な方法は、質問を道具として使って、調査を導くことです。
質問を尋ねると、データセットの特定の部分に注意を集中でき、どのグラフ、モデル、もしくは、変換を作成すべきか決める助けになります。

EDAは基本的に創造的過程です。
ほとんどの創造的過程と同様、*高品質の*質問を尋ねる鍵となるのは、*大量の*質問を生成することです。
分析をはじめたときは、データセットからどんな洞察を拾い集められるのか知らないので、何かを明らかにする質問を尋ねることは困難です。
他方、新しい質問を尋ねるたびにデータの新しい側面が見えてきて、何かを発見する機会が増えていきます。
見つけたことに基づいて質問に質問を重ねることで、データの最も興味深い部分に素早く潜り込み、示唆に富む質問集を作り出せるのです。

研究を導くのにどの質問を尋ねるべきか、には規則はありません。
ただ、データから何かを発見するのに、2つのタイプの質問がいつも役に立ちます。
それらの質問を緩く文章にすると以下のような感じです。

1.  変数内の変動は、どのタイプ？

2.  変数間の共変動は、どのタイプ？

本章の残りの部分は、これら2つの質問を見ていきます。
変動や共変動が何かを説明して、各質問に回答するいくつかの方法を示します。

## 変動

**変動**は、変数の値が測定ごとに変化する傾向です。
実生活で変動を見ることは簡単です。ど
んな連続変数でも2度測定すれば、結果は違っているでしょう。
たとえ光速のような一定の量を測定したとしても、同様です。
測定ごとに小さな誤差を含んでおり、それは測定ごとに違っているからです。
また、異なる対象 (例えば、異なる人々の眼の色) や、異なる時点 (例えば、異なる瞬間での電子のエネルギー水準) で測定すれば、変数は異なります。
全ての変数には独自の変動のパターンがあり、同じ観測での、あるいは、異なる観測間の、測定ごとの変動の仕方について興味深い情報が明らかになりえます。
パターンを理解する最良の方法は、@sec-data-visualization 学習した、変数値分布の可視化です。

`diamonds`データセットから約54,000個のダイアモンドの重さ (`carat`) の分布を可視化することから探索をはじめましょう。
`carat`は数値変数なので、ヒストグラムが使えます。

```{r}
#| fig-alt: |
#|   ダイアモンドのカラットのヒストグラム。x軸は0から4.5、y軸は0から30000の
#|   範囲。分布は右に長く延びており、0が真ん中のビンに入るダイアモンドは
#|   とても少なく、0.5が真ん中のビンには30000近いダイアモンドが入り、
#|   1が真ん中のビンには約15000のダイアモンドが入り、1.5が真ん中のビンには
#|   ずっと少ない約5000のダイアモンドが入る。そこからは、長く尾を引く。

ggplot(diamonds, aes(x = carat)) +
  geom_histogram(binwidth = 0.5)
```

変動を可視化できたところで、プロットの中に何を探すべきでしょうか？
どうゆうタイプの質問を、続けて尋ねるべきでしょうか？
グラフの中から探す最も役立つ情報のタイプと、情報のタイプごとに続けるべき質問のいくつか、をこの先でリストにまとめています。
続けて尋ねる質問を良いものにする鍵は、好奇心 (さらに何を知りたいか？) と懐疑心 (どうにか誤解を招いていないか？) に頼ることです。

### 典型的な値

棒グラフでもヒストグラムでも、高い棒は変数のよくある値を示し、低い棒はあまりない値を示します。
棒がない場所からは、データの中に見られない値だと分かります。
この情報を役立つ質問に変えるには、何であれ予期せぬことを探します。

-   どの値が最もありふれているか？
    その理由は？

-   どの値がまれか？
    その理由は？
    予期した通りだった？

-   変わったパターンは見られないか？
    どう説明が付く？

大きいのを除いたダイアモンドの`carat`分布を見てみましょう。

```{r}
#| fig-alt: |
#|   ダイアモンドのカラットのヒストグラム。x軸は0から3、y軸は0から約2500の
#|   範囲。ビン幅がとても狭い (0.01) ので、ひょろっとした棒がとても多数
#|   並んでいる。分布は右に長く延びる形で、多くのピークの後には高さが減少する
#|   棒が続き、次のピークで急増する。

smaller <- diamonds |> 
  filter(carat < 3)

ggplot(smaller, aes(x = carat)) +
  geom_histogram(binwidth = 0.01)
```

このヒストグラムからは、いくつか興味深い質問が示唆されます。

-   カラットが整数、あるいは、よくある分数で、ダイアモンドが多いのはなぜか？

-   各ピークのやや左側よりもやや右側の方が、ダイアモンドが多いのはなぜか？

可視化はまた、データの中にサブグループが存在することを示唆する、クラスターを明らかにできます。
サブグループを理解するには、次のように尋ねます。

-   各サブグループ内の観測がお互いに似ているのはなぜか？

-   サブグループ間の観測がお互いにどう違っているか？

-   クラスターをどう説明、もしくは、描写できるか？

-   クラスターらしきものが誤解を招いているとしたらなぜか？

これらの質問のいくつかはデータから回答できますが、いくつかはデータに関する専門知識が必要になります。
これら質問の多くは、例えば、ある変数の値が別の変数の動きを説明できないか、といった変数*間*の関係を探索するよう促します。
少し先でそれを探索します。

#### 練習問題

1.  `diamonds`の変数`x`、`y`、`z`それぞれの分布を探索しなさい。
    何が分かりますか？
    ダイアモンドを思い浮かべて、どの次元が長さ、幅、深さとどう決めるか？

2.  `price`の分布を探索しなさい。
    何か異常な、あるいは、驚くことを見つけましたか？
    (ヒント：`binwidth`について注意深く考えて、幅広い値で試してみること。)

3.  0.99カラットのダイアモンドは何個ある？
    1カラットは？
    この差の原因は何？

### 異常値 {#sec-unusual-values-eda}

外れ値は、普通でない観測です。
そのデータ点はパターンにフィットしていなさそうです。
外れ値は、データ入力ミスであることも、このデータ収集でたまたま観測された極端な値というだけのこともありますが、そうでないときは重要な新発見を示唆しています。
大量のデータがある場合、外れ値はヒストグラムでは見づらいことがあります。
例えば、diamondsデータセットの変数yの分布をヒストグラムで見てみましょう。
外れ値があることの証拠は、x軸の範囲が異常に広いことだけです。

```{r}
#| fig-alt: |
#|   ダイアモンドの幅のヒストグラム。x軸は0から60、y軸は0から12000の範囲。
#|   5辺りにピークが一つあり、データはピークの周りに完全に集中している
#|   ように見える。

ggplot(diamonds, aes(x = y)) + 
  geom_histogram(binwidth = 0.5)
```

よくあるビンの中の観測はとても多いので、珍しいビンは非常に短くなっていて、とても見づらくなっています (0をじっと凝視すれば何かあると気付くでしょうが)。
異常値を見やすくするには、`coord_cartesian()`を使って、y軸の小さな値にズームする必要があります。

```{r}
#| fig-alt: |
#|   ダイアモンドの幅のヒストグラム。x軸は0から60、y軸は0から12000の範囲。
#|   5辺りにピークが一つあり、データはピークの周りに完全に集中している
#|   ように見える。それらのデータ以外に、0に高さ約8ののビンが一つ、
#|   30を少し超えた所に高さ1のビンが一つ、
#|   60の少し手前にもう一つ高さ1のビンがある。

ggplot(diamonds, aes(x = y)) + 
  geom_histogram(binwidth = 0.5) +
  coord_cartesian(ylim = c(0, 50))
```

`coord_cartesian()`には、x軸にズームするのに必要な`xlim`引数もあります。
ggplot2には関数の`xlim()`と`ylim()`もありますが、挙動が変わります。範
囲外のデータを投げ捨ててしまいます。
このグラフで、異常値が3つ、0と30辺り、60辺りにあることが見えます。
dplyrを使って、引き抜いてみましょう。

```{r}
#| include: false

old <- options(tibble.print_max = 10, tibble.print_min = 10)
```

```{r}
unusual <- diamonds |> 
  filter(y < 3 | y > 20) |> 
  select(price, x, y, z) |>
  arrange(y)
unusual
```

```{r}
#| include: false

options(old)
```

変数`y`は、ダイアモンドを測定した3次元の一つで、ミリ単位なのです。
幅がゼロミリのダイアモンドなんてありえませんから、これらの値は欠損値に違いありません。
EDAを行うことで、欠損値が0と表記されたデータを見つけたわけです。単
に`NA`を探しただけでは決して見つけられなかったでしょう。
ここから先で誤解を招く計算をしてしまぬよう、これらの値を`NA`に変えることを選ぶかもしれません。
また、32ミリと59ミリの測定もありそうにないと疑うかもしれません。
だって、1インチ超幅の巨大なダイアモンドが何十万ドルもしないなんて！

外れ値を含めたり、外したりして分析を繰り返すことをお薦めします。
結果に影響がほとんどなく、外れ値になっている理由が分からない場合、それらを外して先に進むのが理にかなっています。
しかし、結果に相当な影響がある場合は、正当な理由なくそれらを外すべきではありません。
外れ値になった理由 (例えば、データ入力ミス) を見つけ出し、報告書にはだから外したと開示する必要があります。

データセットの中で異常値に出会って、それでも残りの分析へ進みたい場合、2つのオプションがあります。

1.  奇妙な値のある行全体を落とす。

    ```{r}
    #| eval: false

    diamonds2 <- diamonds |> 
      filter(between(y, 3, 20))
    ```

    このオプションはお薦めしません。無
    効な変数が一つあるだけで、その観測のその他全ての変数も同じく無効とは言えないからです。
    加えて、低品質データの場合、全変数でこのアプローチを適用すると、データが全く残らないかもしれません！

2.  替わりに、異常値は欠損値に置き換えることをお薦めします。
    そうする最も簡単な方法は、`mutate()`を使って、変数を修正後のコピーに置き換えることです。
    `if_else()`関数を使って、異常値を`NA`に置き換えることができます。

    ```{r}
    diamonds2 <- diamonds |> 
      mutate(y = if_else(y < 3 | y > 20, NA, y))
    ```

欠損値はどこにプロットすべきか分からないので、ggplot2はプロットに含めませんが、除いた旨警告します。

```{r}
#| dev: "png"
#| fig-alt: |
#|   ダイアモンドの幅、対、長さの散布図。2変数間には強いリニアな相関がある。
#|   1つを除く全てのダイアモンドは3超の長さ。長さ0、幅6.5辺りに1つ外れ値が
#|   ある。

ggplot(diamonds2, aes(x = x, y = y)) + 
  geom_point()
```

警告を出さないようにするには、`na.rm = TRUE`と設定します。

```{r}
#| eval: false

ggplot(diamonds2, aes(x = x, y = y)) + 
  geom_point(na.rm = TRUE)
```

欠損値がある観測と記録された値がある観測を分けるのは何か、理解したいこともあるでしょう。
例えば、`nycflights13::flights`[^eda-1]では、`dep_time`変数の欠損値は航空便がキャンセルされたことを示しています。
キャンセルされた便とされなかった便で、予定出発時間を比較したいとします。
`is.na()`を使って新変数を作ることで、`dep_time`が欠損値になっているか否かチェックして、これを行うことができます。

[^eda-1]: 関数、または、データセットがどこからのものか明示する必要がある場合は、`package::function()`、または、`package::dataset`という特殊な形式を使うことを、覚えておきましょう。

```{r}
#| fig-alt: |
#|   航空便の予定出発時間の頻度ポリゴン。2つの線がキャンセルされた便と
#|   されなかった便を表す。x軸は0から25時、y軸は0から10000の範囲。
#|   キャンセルされなかった便の数のほうが、された便の数よりずっと多い。 

nycflights13::flights |> 
  mutate(
    cancelled = is.na(dep_time),
    sched_hour = sched_dep_time %/% 100,
    sched_min = sched_dep_time %% 100,
    sched_dep_time = sched_hour + (sched_min / 60)
  ) |> 
  ggplot(aes(x = sched_dep_time)) + 
  geom_freqpoly(aes(color = cancelled), binwidth = 1/4)
```

だが、キャンセルされなかった便の方がされた便よりはるかに多いので、このプロットは上手くありません。
次のセクションでは、この比較を改良するテクニックをいくつか探索します。

#### 練習問題

1.  ヒストグラムでズームする際に、`coord_cartesian()`を使う場合と、`xlim()`か`ylim()`を使う場合を比較、対象しなさい。
    `binwidth`を設定していないとどうなるか？
    棒の半分だけを表すようにズームするとどうなるか？

2.  ヒストグラムでは欠損値はどうなるか？
    棒グラフでは欠損値はどうなるか？
    ヒストグラムと棒グラフで欠損値の扱いが異なる理由は？

3.  `mean()`と`sum()`の中の`na.rm = TRUE`の役目は？

4.  航空便がキャンセルされたか否かで色分けした`scheduled_dep_time`の頻度プロットを再現しなさい。
    `cancelled`変数でファセットしてみなさい。
    ファセット関数内の`scales`引数の値をいろいろと設定して、キャンセルされなかった便がキャンセルされた便より多い影響を低減しなさい。

## 共変動

変動が変数*内*の振る舞いを描写するとすれば、共変動は変数*間*の振る舞いを描写します。
**共変動**は、2つ以上の変数の値が関連して一緒に変動する傾向です。
共変動を見つける最良の方法は、2以上の変数間の関係を可視化することです。

### カテゴリ変数と数値変数 {#sec-cat-num}

例えば、`geom_freqpoly()`を使って、ダイアモンドの価格が (`cut`で測られる) その品質でどう変わるか探索してみましょう。

```{r}
#| fig-alt: |
#|   ダイアモンドの価格の頻度ポリゴン。ダイアモンドの品質 cut (Fair、
#|   Good、Very Good、Premium、Ideal) ごとに違った色の線で表されている。
#|   x軸は0から20000、y軸は0から5000の範囲。線はかなり重なっており、
#|   どの品質でも価格分布は似ていることを示唆。分かりやすい特徴の一つは、
#|   Idealなダイアモンドが1500辺りに最も高いピークを有すること。

ggplot(diamonds, aes(x = price)) + 
  geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)
```

`cut`はデータで順序付きファクタとして定義されているので、ggplot2はそのscaleに順序付き色尺度を使っています。
これらについては、@sec-ordered-factors でさらに学びます。

デフォルトでは、`geom_freqpoly()`の見え方はあまり役立ちません。ビ
ン内のカウントで決まる高さが`cut`ごとに大きく違うので、分布の形の違いが見えにくいからです。

比較を見やすくするためには、y軸に表示されるものを交換する必要があります。
カウントの替わりに、頻度ポリゴン下の面積が1になるよう標準化されたカウントである**密度**を表示します。

```{r}
#| fig-alt: |
#|   ダイアモンドの価格の頻度ポリゴン。ダイアモンドの品質 cut (Fair、
#|   Good、Very Good、Premium、Ideal) ごとに違った色の線で表されている。
#|   x軸は0から20000の範囲。線はかなり重なっており、
#|   どの品質でも価格分布は似ていることを示唆。分かりやすい特徴の一つは、
#|   Fair以外のダイアモンドは皆1500辺りに最も高いピークを有し、
#|   Fairなダイアモンドは他より高い平均を有すること。

ggplot(diamonds, aes(x = price, y = after_stat(density))) + 
  geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)
```

密度 density を`y`にマップしていますが、`diamonds`データセットには`density`という変数はないので、まずそれを計算する必要があります。
`after_stat()`関数を使って、その計算をしています。

このプロットにはかなり驚くべきことがあります。F
airな (最も低品質な) ダイアモンドが最も平均価格が高いなんて！
しかし、頻度ポリゴンの解釈が難しいせいかもしれません。こ
のプロットではいろんなことが起きているのですから。

見た目がもっと簡素なプロットでこの関係を探索するには、ボックスプロットを横に並べることです。

```{r}
#| fig-alt: |
#|   ダイアモンド価格の品質ごとの横並びのボックスプロット。どの品質
#|   (Fair、Good、Very Good、Premium、Ideal) でも価格分布は右に長く
#|   延びている。中央値は、Idealが最も低く、Fairが最も高いが、違いは
#|   大きくない。

ggplot(diamonds, aes(x = cut, y = price)) +
  geom_boxplot()
```

分布に関する情報量は減りましたが、ボックスプロットはずっと簡潔なので、(一つのプロットにいくつも並べて) 比較するのがより容易です。
ここでも、直観に反する発見が支持されています。高
品質ダイアモンドほど典型的には安い！
練習問題で、その理由を見出すよう挑戦されます。

`cut`は順序付きファクタです。F
airはGoodより悪く、GoodはVery Goodよりも悪い、と続きます。
多くのカテゴリ変数でもそのような本質的な順序はないので、より分かりやすく表示するためにカテゴリ変数の順序を変更 reorder したいかもしれません。
そうするための一つの方法が、`fct_reorder()`を使うことです。
この関数については @sec-modifying-factor-order で、さらに学習しますが、とても役に立つ関数なので、ここでちょっとプレビューを示しておきます。
例えば、`mpg`データセットの`class`変数を取り上げます。
classごとに高速道路での燃料効率がどう違うのか興味があるとします。

```{r}
#| fig-alt: |
#|   車の高速道路での燃料効率のクラスごとの横並びのボックスプロット。
#|   クラス (2seaters、compact、midsize、minivan、pickup、subcompact、suv)
#|   はx軸上にある。

ggplot(mpg, aes(x = class, y = hwy)) +
  geom_boxplot()
```

傾向を見やすくするために、`hwy`の中央値に基づいて`class`をreorderできます。

```{r}
#| fig-alt: |
#|   車の高速道路での燃料効率のクラスごとの横並びのボックスプロット。
#|   クラス (2seaters、compact、midsize、minivan、pickup、subcompact、suv)
#|   はx軸上にあり、高速道路での燃料効率の中央値が増える順に左から並ぶ。

ggplot(mpg, aes(x = fct_reorder(class, hwy, median), y = hwy)) +
  geom_boxplot()
```

変数名が長い場合、90度回転した方が`geom_boxplot()`は見栄えが良いです。
外観属性xとyへのマッピングを交換すると、90度回転できます。

```{r}
#| fig-alt: |
#|   車の高速道路での燃料効率のクラスごとの横並びのボックスプロット。
#|   クラス (2seaters、compact、midsize、minivan、pickup、subcompact、suv)
#|   はy軸上にあり、高速道路での燃料効率の中央値が増える順に下から並ぶ。

ggplot(mpg, aes(x = hwy, y = fct_reorder(class, hwy, median))) +
  geom_boxplot()
```

#### 練習問題

1.  学んだことを使って、キャンセルされた便とされなかった便の予定出発時間の可視化を改良しなさい。

2.  EDAに基づくと、diamondsデータセットのどの変数が、価格を予測するのに最も重要に見えるか？
    どの変数とcutはどう相関しているか？
    その2変数の組み合わせが、低品質ダイアモンドほど高価にしている理由は？

3.  垂直なボックスプロットから水平なボックスプロットに変更するために、xとyの変数を入れ替えるのではなく、`coord_flip()`を新しいレイヤーとして加えなさい。
    変数を入れ替えたものとどこか違いますか？

4.  ボックスプロットの問題の一つは、ずっと小さなデータセットの時代に開発されたために、"外れ値"をあまりに大量に表示しがちなことです。
    この問題を治療する一つのアプローチは、letter value プロットです。
    lvplotパッケージをインストールして、`geom_lv()`を使ってprice 対 cut の分布を表示しなさい。
    何が分かりますか？
    プロットをどう解釈しますか？

5.  `diamonds`データセットのダイアモンド価格、対、カテゴリ変数を可視化しなさい。
    最初は`geom_violin()`を使い、次にファセットした`geom_histogram()`、次に色分けした`geom_freqpoly()`、そして、色分けした`geom_density()`で作成しなさい。
    4つのプロットを比較、対照しなさい。
    カテゴリ変数の水準別に数値変数の分布を可視化する各方法の良い点と悪い点は何か？

6.  データセットが小さい場合、`geom_jitter()`を使ってoverplottingを回避すると、連続変数とカテゴリ変数間の関係が見やすくなって役に立つことがあります。
    ggbeeswarmパッケージは`geom_jitter()`に似た手法をいくつか提供しています。
    それらをリストにして、それぞれが何をするか、関係に記述しなさい。

### 2つのカテゴリ変数

カテゴリ変数間の共変動を可視化するには、これらのカテゴリ変数の水準の組み合わせごとに観測数をカウントする必要があります。
一つの方法はggplot2に含まれている`geom_count()`に頼ることです。

```{r}
#| fig-alt: |
#|   ダイアモンドのcolor対cutの散布図。
#|   cutの水準 (Fair、Good、Very Good、Premium、Ideal) と
#|   colorの水準 (D、E、F、G、H、I、J) の組み合わせごとに一つの点がある。
#|   点のサイズがその組み合わせの観測数を表す。
#|   凡例はサイズは主に1000から4000までの範囲にあることを示す。

ggplot(diamonds, aes(x = cut, y = color)) +
  geom_count()
```

プロットの各丸のサイズは値の組み合わせごとの観測数を表しています。
特定のx値と特定のy値の間に強い相関があるとき、共変動は現れます。

これら変数間の関係を探索するもう一つのアプローチは、dplyrを使ってカウントを計算することです。

```{r}
diamonds |> 
  count(color, cut)
```

それから、`geom_tile()`で外観属性fillを使って可視化します。

```{r}
#| fig-alt: |
#|   ダイアモンドのcut対colorのタイル・プロット。
#|   各タイルはcut/colorを表しており、そこでの観測数に従って
#|   色付けされている。
#|   cutで一番多いのはIdealで、cut/colorで一番多いのはIdeal/G
#|   、一番少ないのはFair/J。

diamonds |> 
  count(color, cut) |>  
  ggplot(aes(x = color, y = cut)) +
  geom_tile(aes(fill = n))
```

カテゴリ変数に順序がないのなら、興味深いパターンをより分かりやすくするために、 seriationパッケージを使って、行と列を同時に並べ直したいかもしれません。
さらに大きなプロットでは、heatmaplyパッケージを使って、インターアクティブなプロットを作成したいかもしれません。

#### 練習問題

1.  How could you rescale the count dataset above to more clearly show the distribution of cut within color, or color within cut?

2.  What different data insights do you get with a segmented bar chart if color is mapped to the `x` aesthetic and `cut` is mapped to the `fill` aesthetic?
    Calculate the counts that fall into each of the segments.

3.  Use `geom_tile()` together with dplyr to explore how average flight departure delays vary by destination and month of year.
    What makes the plot difficult to read?
    How could you improve it?

### Two numerical variables

You've already seen one great way to visualize the covariation between two numerical variables: draw a scatterplot with `geom_point()`.
You can see covariation as a pattern in the points.
For example, you can see a positive relationship between the carat size and price of a diamond: diamonds with more carats have a higher price.
The relationship is exponential.

```{r}
#| dev: "png"
#| fig-alt: |
#|   A scatterplot of price vs. carat. The relationship is positive, somewhat 
#|   strong, and exponential.

ggplot(smaller, aes(x = carat, y = price)) +
  geom_point()
```

(In this section we'll use the `smaller` dataset to stay focused on the bulk of the diamonds that are smaller than 3 carats)

Scatterplots become less useful as the size of your dataset grows, because points begin to overplot, and pile up into areas of uniform black, making it hard to judge differences in the density of the data across the 2-dimensional space as well as making it hard to spot the trend.
You've already seen one way to fix the problem: using the `alpha` aesthetic to add transparency.

```{r}
#| dev: "png"
#| fig-alt: |
#|   A scatterplot of price vs. carat. The relationship is positive, somewhat 
#|   strong, and exponential. The points are transparent, showing clusters where 
#|   the number of points is higher than other areas, The most obvious clusters 
#|   are for diamonds with 1, 1.5, and 2 carats.

ggplot(smaller, aes(x = carat, y = price)) + 
  geom_point(alpha = 1 / 100)
```

But using transparency can be challenging for very large datasets.
Another solution is to use bin.
Previously you used `geom_histogram()` and `geom_freqpoly()` to bin in one dimension.
Now you'll learn how to use `geom_bin2d()` and `geom_hex()` to bin in two dimensions.

`geom_bin2d()` and `geom_hex()` divide the coordinate plane into 2d bins and then use a fill color to display how many points fall into each bin.
`geom_bin2d()` creates rectangular bins.
`geom_hex()` creates hexagonal bins.
You will need to install the hexbin package to use `geom_hex()`.

```{r}
#| layout-ncol: 2
#| fig-width: 3
#| fig-alt: |
#|   Plot 1: A binned density plot of price vs. carat. Plot 2: A hexagonal bin 
#|   plot of price vs. carat. Both plots show that the highest density of 
#|   diamonds have low carats and low prices.

ggplot(smaller, aes(x = carat, y = price)) +
  geom_bin2d()

# install.packages("hexbin")
ggplot(smaller, aes(x = carat, y = price)) +
  geom_hex()
```

Another option is to bin one continuous variable so it acts like a categorical variable.
Then you can use one of the techniques for visualizing the combination of a categorical and a continuous variable that you learned about.
For example, you could bin `carat` and then for each group, display a boxplot:

```{r}
#| fig-alt: |
#|   Side-by-side box plots of price by carat. Each box plot represents diamonds 
#|   that are 0.1 carats apart in weight. The box plots show that as carat 
#|   increases the median price increases as well. Additionally, diamonds with 
#|   1.5 carats or lower have right skewed price distributions, 1.5 to 2 have 
#|   roughly symmetric price distributions, and diamonds that weigh more have 
#|   left skewed distributions. Cheaper, smaller diamonds have outliers on the 
#|   higher end, more expensive, bigger diamonds have outliers on the lower end.

ggplot(smaller, aes(x = carat, y = price)) + 
  geom_boxplot(aes(group = cut_width(carat, 0.1)))
```

`cut_width(x, width)`, as used above, divides `x` into bins of width `width`.
By default, boxplots look roughly the same (apart from number of outliers) regardless of how many observations there are, so it's difficult to tell that each boxplot summaries a different number of points.
One way to show that is to make the width of the boxplot proportional to the number of points with `varwidth = TRUE`.

#### Exercises

1.  Instead of summarizing the conditional distribution with a boxplot, you could use a frequency polygon.
    What do you need to consider when using `cut_width()` vs. `cut_number()`?
    How does that impact a visualization of the 2d distribution of `carat` and `price`?

2.  Visualize the distribution of `carat`, partitioned by `price`.

3.  How does the price distribution of very large diamonds compare to small diamonds?
    Is it as you expect, or does it surprise you?

4.  Combine two of the techniques you've learned to visualize the combined distribution of cut, carat, and price.

5.  Two dimensional plots reveal outliers that are not visible in one dimensional plots.
    For example, some points in the following plot have an unusual combination of `x` and `y` values, which makes the points outliers even though their `x` and `y` values appear normal when examined separately.
    Why is a scatterplot a better display than a binned plot for this case?

    ```{r}
    #| eval: false
    diamonds |> 
      filter(x >= 4) |> 
      ggplot(aes(x = x, y = y)) +
      geom_point() +
      coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))
    ```

6.  Instead of creating boxes of equal width with `cut_width()`, we could create boxes that contain roughly equal number of points with `cut_number()`.
    What are the advantages and disadvantages of this approach?

    ```{r}
    #| eval: false
    ggplot(smaller, aes(x = carat, y = price)) + 
      geom_boxplot(aes(group = cut_number(carat, 20)))
    ```

## Patterns and models

If a systematic relationship exists between two variables it will appear as a pattern in the data.
If you spot a pattern, ask yourself:

-   Could this pattern be due to coincidence (i.e. random chance)?

-   How can you describe the relationship implied by the pattern?

-   How strong is the relationship implied by the pattern?

-   What other variables might affect the relationship?

-   Does the relationship change if you look at individual subgroups of the data?

Patterns in your data provide clues about relationships, i.e., they reveal covariation.
If you think of variation as a phenomenon that creates uncertainty, covariation is a phenomenon that reduces it.
If two variables covary, you can use the values of one variable to make better predictions about the values of the second.
If the covariation is due to a causal relationship (a special case), then you can use the value of one variable to control the value of the second.

Models are a tool for extracting patterns out of data.
For example, consider the diamonds data.
It's hard to understand the relationship between cut and price, because cut and carat, and carat and price are tightly related.
It's possible to use a model to remove the very strong relationship between price and carat so we can explore the subtleties that remain.
The following code fits a model that predicts `price` from `carat` and then computes the residuals (the difference between the predicted value and the actual value).
The residuals give us a view of the price of the diamond, once the effect of carat has been removed.
Note that instead of using the raw values of `price` and `carat`, we log transform them first, and fit a model to the log-transformed values.
Then, we exponentiate the residuals to put them back in the scale of raw prices.

```{r}
#| message: false
#| dev: "png"
#| fig-alt: |
#|   A scatterplot of residuals vs. carat of diamonds. The x-axis ranges from 0 
#|   to 5, the y-axis ranges from 0 to almost 4. Much of the data are clustered 
#|   around low values of carat and residuals. There is a clear, curved pattern 
#|   showing decrease in residuals as carat increases.

library(tidymodels)

diamonds <- diamonds |>
  mutate(
    log_price = log(price),
    log_carat = log(carat)
  )

diamonds_fit <- linear_reg() |>
  fit(log_price ~ log_carat, data = diamonds)

diamonds_aug <- augment(diamonds_fit, new_data = diamonds) |>
  mutate(.resid = exp(.resid))

ggplot(diamonds_aug, aes(x = carat, y = .resid)) + 
  geom_point()
```

Once you've removed the strong relationship between carat and price, you can see what you expect in the relationship between cut and price: relative to their size, better quality diamonds are more expensive.

```{r}
#| fig-alt: |
#|   Side-by-side box plots of residuals by cut. The x-axis displays the various 
#|   cuts (Fair to Ideal), the y-axis ranges from 0 to almost 5. The medians are 
#|   quite similar, between roughly 0.75 to 1.25. Each of the distributions of 
#|   residuals is right skewed, with many outliers on the higher end.

ggplot(diamonds_aug, aes(x = cut, y = .resid)) + 
  geom_boxplot()
```

We're not discussing modelling in this book because understanding what models are and how they work is easiest once you have tools of data wrangling and programming in hand.

## Summary

In this chapter you've learned a variety of tools to help you understand the variation within your data.
You've seen techniques that work with a single variable at a time and with a pair of variables.
This might seem painfully restrictive if you have tens or hundreds of variables in your data, but they're the foundation upon which all other techniques are built.

In the next chapter, we'll focus on the tools we can use to communicate our results.
