# 探索的データ分析 {#sec-exploratory-data-analysis}

```{r}
#| echo: false

source("_common.R")
```

## はじめに

本章では、可視化と変換を使って、統計学者が探索的データ分析 (略してEDA) と呼ぶ、データを探索する組織立った方法を示します。
EDAは反復サイクルです。
あなたは、

1.  データについて質問を生成します。

2.  データを可視化、変換、モデル化して、回答を探します。

3.  分かったことを使って質問を精錬させる、もしくは、新しい質問を生成する。

EDAは厳格な規則集がある正式な過程ではありません。
EDAは何よりもまず、心の持ち様なのです。
EDAの初期段階では思いついた全てのアイディアを気ままに調査すべきです。
いくつかのアイディアは広がり、またいくつかのアイディアは行き詰まります。
探索を続けるうちに、2、3の特に実りある洞察を行き着き、最終的には報告書を書き上げて他者に伝達することになります。

EDAはどんなデータ分析でも重要な部分です。た
とえ、研究の第一義的な質問が盆に載せて手渡されたとしても、データ品質を調べる必要が常にある以上、EDAは欠かせません。
データ・クリーニングはEDAの一つの応用に過ぎません。デ
ータが期待に沿うものか否かの質問にあたります。
データ・クリーニングを行うには、可視化、変換、モデル化といったEDAの全ての道具を持ち出す必要があります。

### 準備するもの

本章では、dplyrとggplot2について学習したことを組み合わせて、質問を尋ね、データを使って回答、そしてまた新しい質問を尋ねることを繰り返します。

```{r}
#| label: setup
#| message: false

library(tidyverse)
```

## 質問

> "決まりきった統計上の質問などない。あるのは疑わしい統計の決まりきった手順だけだ。" --- Sir David Cox

> "間違った質問への常に精密にできる正確な回答よりも、正しい質問への大まかでたいてい曖昧な回答の方がずっと良い。" --- John Tukey

EDAでのゴールはデータの理解を深めることです。
最も簡単な方法は、質問を道具として使って、調査を導くことです。
質問を尋ねると、データセットの特定の部分に注意を集中でき、どのグラフ、モデル、もしくは、変換を作成すべきか決める助けになります。

EDAは基本的に創造的過程です。
ほとんどの創造的過程と同様、*高品質の*質問を尋ねる鍵となるのは、*大量の*質問を生成することです。
分析をはじめたときは、データセットからどんな洞察を拾い集められるのか知らないので、何かを明らかにする質問を尋ねることは困難です。
他方、新しい質問を尋ねるたびにデータの新しい側面が見えてきて、何かを発見する機会が増えていきます。
見つけたことに基づいて質問に質問を重ねることで、データの最も興味深い部分に素早く潜り込み、示唆に富む質問集を作り出せるのです。

研究を導くのにどの質問を尋ねるべきか、には規則はありません。
ただ、データから何かを発見するのに、2つのタイプの質問がいつも役に立ちます。
それらの質問を緩く文章にすると以下のような感じです。

1.  変数内の変動は、どのタイプ？

2.  変数間の共変動は、どのタイプ？

本章の残りの部分は、これら2つの質問を見ていきます。
変動や共変動が何かを説明して、各質問に回答するいくつかの方法を示します。

## 変動

**変動**は、変数の値が測定ごとに変化する傾向です。
実生活で変動を見ることは簡単です。ど
んな連続変数でも2度測定すれば、結果は違っているでしょう。
たとえ光速のような一定の量を測定したとしても、同様です。
測定ごとに小さな誤差を含んでおり、それは測定ごとに違っているからです。
また、異なる対象 (例えば、異なる人々の眼の色) や、異なる時点 (例えば、異なる瞬間での電子のエネルギー水準) で測定すれば、変数は異なります。
全ての変数には独自の変動のパターンがあり、同じ観測での、あるいは、異なる観測間の、測定ごとの変動の仕方について興味深い情報が明らかになりえます。
パターンを理解する最良の方法は、@sec-data-visualization 学習した、変数値分布の可視化です。

`diamonds`データセットから約54,000個のダイアモンドの重さ (`carat`) の分布を可視化することから探索をはじめましょう。
`carat`は数値変数なので、ヒストグラムが使えます。

```{r}
#| fig-alt: |
#|   ダイアモンドのカラットのヒストグラム。x軸は0から4.5、y軸は0から30000の
#|   範囲。分布は右に長く延びており、0が真ん中のビンに入るダイアモンドは
#|   とても少なく、0.5が真ん中のビンには30000近いダイアモンドが入り、
#|   1が真ん中のビンには約15000のダイアモンドが入り、1.5が真ん中のビンには
#|   ずっと少ない約5000のダイアモンドが入る。そこからは、長く尾を引く。

ggplot(diamonds, aes(x = carat)) +
  geom_histogram(binwidth = 0.5)
```

変動を可視化できたところで、プロットの中に何を探すべきでしょうか？
どうゆうタイプの質問を、続けて尋ねるべきでしょうか？
グラフの中から探す最も役立つ情報のタイプと、情報のタイプごとに続けるべき質問のいくつか、をこの先でリストにまとめています。
続けて尋ねる質問を良いものにする鍵は、好奇心 (さらに何を知りたいか？) と懐疑心 (どうにか誤解を招いていないか？) に頼ることです。

### 典型的な値

棒グラフでもヒストグラムでも、高い棒は変数のよくある値を示し、低い棒はあまりない値を示します。
棒がない場所からは、データの中に見られない値だと分かります。
この情報を役立つ質問に変えるには、何であれ予期せぬことを探します。

-   どの値が最もありふれているか？
    その理由は？

-   どの値がまれか？
    その理由は？
    予期した通りだった？

-   変わったパターンは見られないか？
    どう説明が付く？

大きいのを除いたダイアモンドの`carat`分布を見てみましょう。

```{r}
#| fig-alt: |
#|   ダイアモンドのカラットのヒストグラム。x軸は0から3、y軸は0から約2500の
#|   範囲。ビン幅がとても狭い (0.01) ので、ひょろっとした棒がとても多数
#|   並んでいる。分布は右に長く延びる形で、多くのピークの後には高さが減少する
#|   棒が続き、次のピークで急増する。

smaller <- diamonds |> 
  filter(carat < 3)

ggplot(smaller, aes(x = carat)) +
  geom_histogram(binwidth = 0.01)
```

このヒストグラムからは、いくつか興味深い質問が示唆されます。

-   カラットが整数、あるいは、よくある分数で、ダイアモンドが多いのはなぜか？

-   各ピークのやや左側よりもやや右側の方が、ダイアモンドが多いのはなぜか？

可視化はまた、データの中にサブグループが存在することを示唆する、クラスターを明らかにできます。
サブグループを理解するには、次のように尋ねます。

-   各サブグループ内の観測がお互いに似ているのはなぜか？

-   サブグループ間の観測がお互いにどう違っているか？

-   クラスターをどう説明、もしくは、描写できるか？

-   クラスターらしきものが誤解を招いているとしたらなぜか？

これらの質問のいくつかはデータから回答できますが、いくつかはデータに関する専門知識が必要になります。
これら質問の多くは、例えば、ある変数の値が別の変数の動きを説明できないか、といった変数*間*の関係を探索するよう促します。
少し先でそれを探索します。

#### 練習問題

1.  `diamonds`の変数`x`、`y`、`z`それぞれの分布を探索しなさい。
    何が分かりますか？
    ダイアモンドを思い浮かべて、どの次元が長さ、幅、深さとどう決めるか？

2.  `price`の分布を探索しなさい。
    何か異常な、あるいは、驚くことを見つけましたか？
    (ヒント：`binwidth`について注意深く考えて、幅広い値で試してみること。)

3.  0.99カラットのダイアモンドは何個ある？
    1カラットは？
    この差の原因は何？

### 異常値 {#sec-unusual-values-eda}

外れ値は、普通でない観測です。
そのデータ点はパターンにフィットしていなさそうです。
外れ値は、データ入力ミスであることも、このデータ収集でたまたま観測された極端な値というだけのこともありますが、そうでないときは重要な新発見を示唆しています。
大量のデータがある場合、外れ値はヒストグラムでは見づらいことがあります。
例えば、diamondsデータセットの変数yの分布をヒストグラムで見てみましょう。
外れ値があることの証拠は、x軸の範囲が異常に広いことだけです。

```{r}
#| fig-alt: |
#|   ダイアモンドの幅のヒストグラム。x軸は0から60、y軸は0から12000の範囲。
#|   5辺りにピークが一つあり、データはピークの周りに完全に集中している
#|   ように見える。

ggplot(diamonds, aes(x = y)) + 
  geom_histogram(binwidth = 0.5)
```

よくあるビンの中の観測はとても多いので、珍しいビンは非常に短くなっていて、とても見づらくなっています (0をじっと凝視すれば何かあると気付くでしょうが)。
異常値を見やすくするには、`coord_cartesian()`を使って、y軸の小さな値にズームする必要があります。

```{r}
#| fig-alt: |
#|   ダイアモンドの幅のヒストグラム。x軸は0から60、y軸は0から12000の範囲。
#|   5辺りにピークが一つあり、データはピークの周りに完全に集中している
#|   ように見える。それらのデータ以外に、0に高さ約8ののビンが一つ、
#|   30を少し超えた所に高さ1のビンが一つ、
#|   60の少し手前にもう一つ高さ1のビンがある。

ggplot(diamonds, aes(x = y)) + 
  geom_histogram(binwidth = 0.5) +
  coord_cartesian(ylim = c(0, 50))
```

`coord_cartesian()`には、x軸にズームするのに必要な`xlim`引数もあります。
ggplot2には関数の`xlim()`と`ylim()`もありますが、挙動が変わります。範
囲外のデータを投げ捨ててしまいます。
このグラフで、異常値が3つ、0と30辺り、60辺りにあることが見えます。
dplyrを使って、引き抜いてみましょう。

```{r}
#| include: false

old <- options(tibble.print_max = 10, tibble.print_min = 10)
```

```{r}
unusual <- diamonds |> 
  filter(y < 3 | y > 20) |> 
  select(price, x, y, z) |>
  arrange(y)
unusual
```

```{r}
#| include: false

options(old)
```

変数`y`は、ダイアモンドを測定した3次元の一つで、ミリ単位なのです。
幅がゼロミリのダイアモンドなんてありえませんから、これらの値は欠損値に違いありません。
EDAを行うことで、欠損値が0と表記されたデータを見つけたわけです。単
に`NA`を探しただけでは決して見つけられなかったでしょう。
ここから先で誤解を招く計算をしてしまぬよう、これらの値を`NA`に変えることを選ぶかもしれません。
また、32ミリと59ミリの測定もありそうにないと疑うかもしれません。
だって、1インチ超幅の巨大なダイアモンドが何十万ドルもしないなんて！

外れ値を含めたり、外したりして分析を繰り返すことをお薦めします。
結果に影響がほとんどなく、外れ値になっている理由が分からない場合、それらを外して先に進むのが理にかなっています。
しかし、結果に相当な影響がある場合は、正当な理由なくそれらを外すべきではありません。
外れ値になった理由 (例えば、データ入力ミス) を見つけ出し、報告書にはだから外したと開示する必要があります。

データセットの中で異常値に出会って、それでも残りの分析へ進みたい場合、2つのオプションがあります。

1.  奇妙な値のある行全体を落とす。

    ```{r}
    #| eval: false

    diamonds2 <- diamonds |> 
      filter(between(y, 3, 20))
    ```

    このオプションはお薦めしません。無
    効な変数が一つあるだけで、その観測のその他全ての変数も同じく無効とは言えないからです。
    加えて、低品質データの場合、全変数でこのアプローチを適用すると、データが全く残らないかもしれません！

2.  替わりに、異常値は欠損値に置き換えることをお薦めします。
    そうする最も簡単な方法は、`mutate()`を使って、変数を修正後のコピーに置き換えることです。
    `if_else()`関数を使って、異常値を`NA`に置き換えることができます。

    ```{r}
    diamonds2 <- diamonds |> 
      mutate(y = if_else(y < 3 | y > 20, NA, y))
    ```

欠損値はどこにプロットすべきか分からないので、ggplot2はプロットに含めませんが、除いた旨警告します。

```{r}
#| dev: "png"
#| fig-alt: |
#|   ダイアモンドの幅、対、長さの散布図。2変数間には強いリニアな相関がある。
#|   1つを除く全てのダイアモンドは3超の長さ。長さ0、幅6.5辺りに1つ外れ値が
#|   ある。

ggplot(diamonds2, aes(x = x, y = y)) + 
  geom_point()
```

警告を出さないようにするには、`na.rm = TRUE`と設定します。

```{r}
#| eval: false

ggplot(diamonds2, aes(x = x, y = y)) + 
  geom_point(na.rm = TRUE)
```

欠損値がある観測と記録された値がある観測を分けるのは何か、理解したいこともあるでしょう。
例えば、`nycflights13::flights`[^eda-1]では、`dep_time`変数の欠損値は航空便がキャンセルされたことを示しています。
キャンセルされた便とされなかった便で、予定出発時間を比較したいとします。
`is.na()`を使って新変数を作ることで、`dep_time`が欠損値になっているか否かチェックして、これを行うことができます。

[^eda-1]: 関数、または、データセットがどこからのものか明示する必要がある場合は、`package::function()`、または、`package::dataset`という特殊な形式を使うことを、覚えておきましょう。

```{r}
#| fig-alt: |
#|   航空便の予定出発時間の頻度ポリゴン。2つの線がキャンセルされた便と
#|   されなかった便を表す。x軸は0から25時、y軸は0から10000の範囲。
#|   キャンセルされなかった便の数のほうが、された便の数よりずっと多い。 

nycflights13::flights |> 
  mutate(
    cancelled = is.na(dep_time),
    sched_hour = sched_dep_time %/% 100,
    sched_min = sched_dep_time %% 100,
    sched_dep_time = sched_hour + (sched_min / 60)
  ) |> 
  ggplot(aes(x = sched_dep_time)) + 
  geom_freqpoly(aes(color = cancelled), binwidth = 1/4)
```

だが、キャンセルされなかった便の方がされた便よりはるかに多いので、このプロットは上手くありません。
次のセクションでは、この比較を改良するテクニックをいくつか探索します。

#### 練習問題

1.  ヒストグラムでズームする際に、`coord_cartesian()`を使う場合と、`xlim()`か`ylim()`を使う場合を比較、対象しなさい。
    `binwidth`を設定していないとどうなるか？
    棒の半分だけを表すようにズームするとどうなるか？

2.  ヒストグラムでは欠損値はどうなるか？
    棒グラフでは欠損値はどうなるか？
    ヒストグラムと棒グラフで欠損値の扱いが異なる理由は？

3.  `mean()`と`sum()`の中の`na.rm = TRUE`の役目は？

4.  航空便がキャンセルされたか否かで色分けした`scheduled_dep_time`の頻度プロットを再現しなさい。
    `cancelled`変数でファセットしてみなさい。
    ファセット関数内の`scales`引数の値をいろいろと設定して、キャンセルされなかった便がキャンセルされた便より多い影響を低減しなさい。

## 共変動

変動が変数*内*の振る舞いを描写するとすれば、共変動は変数*間*の振る舞いを描写します。
**共変動**は、2つ以上の変数の値が関連して一緒に変動する傾向です。
共変動を見つける最良の方法は、2以上の変数間の関係を可視化することです。

### カテゴリ変数と数値変数 {#sec-cat-num}

例えば、`geom_freqpoly()`を使って、ダイアモンドの価格が (`cut`で測られる) その品質でどう変わるか探索してみましょう。

```{r}
#| fig-alt: |
#|   ダイアモンドの価格の頻度ポリゴン。ダイアモンドの品質 cut (Fair、
#|   Good、Very Good、Premium、Ideal) ごとに違った色の線で表されている。
#|   x軸は0から20000、y軸は0から5000の範囲。線はかなり重なっており、
#|   どの品質でも価格分布は似ていることを示唆。分かりやすい特徴の一つは、
#|   Idealなダイアモンドが1500辺りに最も高いピークを有すること。

ggplot(diamonds, aes(x = price)) + 
  geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)
```

`cut`はデータで順序付きファクタとして定義されているので、ggplot2はそのscaleに順序付き色尺度を使っています。
これらについては、@sec-ordered-factors でさらに学びます。

デフォルトでは、`geom_freqpoly()`の見え方はあまり役立ちません。ビ
ン内のカウントで決まる高さが`cut`ごとに大きく違うので、分布の形の違いが見えにくいからです。

比較を見やすくするためには、y軸に表示されるものを交換する必要があります。
カウントの替わりに、頻度ポリゴン下の面積が1になるよう標準化されたカウントである**密度**を表示します。

```{r}
#| fig-alt: |
#|   ダイアモンドの価格の頻度ポリゴン。ダイアモンドの品質 cut (Fair、
#|   Good、Very Good、Premium、Ideal) ごとに違った色の線で表されている。
#|   x軸は0から20000の範囲。線はかなり重なっており、
#|   どの品質でも価格分布は似ていることを示唆。分かりやすい特徴の一つは、
#|   Fair以外のダイアモンドは皆1500辺りに最も高いピークを有し、
#|   Fairなダイアモンドは他より高い平均を有すること。

ggplot(diamonds, aes(x = price, y = after_stat(density))) + 
  geom_freqpoly(aes(color = cut), binwidth = 500, linewidth = 0.75)
```

密度 density を`y`にマップしていますが、`diamonds`データセットには`density`という変数はないので、まずそれを計算する必要があります。
`after_stat()`関数を使って、その計算をしています。

このプロットにはかなり驚くべきことがあります。F
airな (最も低品質な) ダイアモンドが最も平均価格が高いなんて！
しかし、頻度ポリゴンの解釈が難しいせいかもしれません。こ
のプロットではいろんなことが起きているのですから。

見た目がもっと簡素なプロットでこの関係を探索するには、ボックスプロットを横に並べることです。

```{r}
#| fig-alt: |
#|   ダイアモンド価格の品質ごとの横並びのボックスプロット。どの品質
#|   (Fair、Good、Very Good、Premium、Ideal) でも価格分布は右に長く
#|   延びている。中央値は、Idealが最も低く、Fairが最も高いが、違いは
#|   大きくない。

ggplot(diamonds, aes(x = cut, y = price)) +
  geom_boxplot()
```

分布に関する情報量は減りましたが、ボックスプロットはずっと簡潔なので、(一つのプロットにいくつも並べて) 比較するのがより容易です。
ここでも、直観に反する発見が支持されています。高
品質ダイアモンドほど典型的には安い！
練習問題で、その理由を見出すよう挑戦されます。

`cut`は順序付きファクタです。F
airはGoodより悪く、GoodはVery Goodよりも悪い、と続きます。
多くのカテゴリ変数でもそのような本質的な順序はないので、より分かりやすく表示するためにカテゴリ変数の順序を変更 reorder したいかもしれません。
そうするための一つの方法が、`fct_reorder()`を使うことです。
この関数については @sec-modifying-factor-order で、さらに学習しますが、とても役に立つ関数なので、ここでちょっとプレビューを示しておきます。
例えば、`mpg`データセットの`class`変数を取り上げます。
classごとに高速道路での燃料効率がどう違うのか興味があるとします。

```{r}
#| fig-alt: |
#|   車の高速道路での燃料効率のクラスごとの横並びのボックスプロット。
#|   クラス (2seaters、compact、midsize、minivan、pickup、subcompact、suv)
#|   はx軸上にある。

ggplot(mpg, aes(x = class, y = hwy)) +
  geom_boxplot()
```

傾向を見やすくするために、`hwy`の中央値に基づいて`class`をreorderできます。

```{r}
#| fig-alt: |
#|   車の高速道路での燃料効率のクラスごとの横並びのボックスプロット。
#|   クラス (2seaters、compact、midsize、minivan、pickup、subcompact、suv)
#|   はx軸上にあり、高速道路での燃料効率の中央値が増える順に左から並ぶ。

ggplot(mpg, aes(x = fct_reorder(class, hwy, median), y = hwy)) +
  geom_boxplot()
```

変数名が長い場合、90度回転した方が`geom_boxplot()`は見栄えが良いです。
外観属性xとyへのマッピングを交換すると、90度回転できます。

```{r}
#| fig-alt: |
#|   車の高速道路での燃料効率のクラスごとの横並びのボックスプロット。
#|   クラス (2seaters、compact、midsize、minivan、pickup、subcompact、suv)
#|   はy軸上にあり、高速道路での燃料効率の中央値が増える順に下から並ぶ。

ggplot(mpg, aes(x = hwy, y = fct_reorder(class, hwy, median))) +
  geom_boxplot()
```

#### 練習問題

1.  学んだことを使って、キャンセルされた便とされなかった便の予定出発時間の可視化を改良しなさい。

2.  EDAに基づくと、diamondsデータセットのどの変数が、価格を予測するのに最も重要に見えるか？
    どの変数とcutはどう相関しているか？
    その2変数の組み合わせが、低品質ダイアモンドほど高価にしている理由は？

3.  垂直なボックスプロットから水平なボックスプロットに変更するために、xとyの変数を入れ替えるのではなく、`coord_flip()`を新しいレイヤーとして加えなさい。
    変数を入れ替えたものとどこか違いますか？

4.  ボックスプロットの問題の一つは、ずっと小さなデータセットの時代に開発されたために、"外れ値"をあまりに大量に表示しがちなことです。
    この問題を治療する一つのアプローチは、letter value プロットです。
    lvplotパッケージをインストールして、`geom_lv()`を使ってprice 対 cut の分布を表示しなさい。
    何が分かりますか？
    プロットをどう解釈しますか？

5.  `diamonds`データセットのダイアモンド価格、対、カテゴリ変数を可視化しなさい。
    最初は`geom_violin()`を使い、次にファセットした`geom_histogram()`、次に色分けした`geom_freqpoly()`、そして、色分けした`geom_density()`で作成しなさい。
    4つのプロットを比較、対照しなさい。
    カテゴリ変数の水準別に数値変数の分布を可視化する各方法の良い点と悪い点は何か？

6.  データセットが小さい場合、`geom_jitter()`を使ってオーバープロットを回避すると、連続変数とカテゴリ変数間の関係が見やすくなって役に立つことがあります。
    ggbeeswarmパッケージは`geom_jitter()`に似た手法をいくつか提供しています。
    それらをリストにして、それぞれが何をするか、関係に記述しなさい。

### 2つのカテゴリ変数

カテゴリ変数間の共変動を可視化するには、これらのカテゴリ変数の水準の組み合わせごとに観測数をカウントする必要があります。
一つの方法はggplot2に含まれている`geom_count()`に頼ることです。

```{r}
#| fig-alt: |
#|   ダイアモンドのcolor対cutの散布図。
#|   cutの水準 (Fair、Good、Very Good、Premium、Ideal) と
#|   colorの水準 (D、E、F、G、H、I、J) の組み合わせごとに一つの点がある。
#|   点のサイズがその組み合わせの観測数を表す。
#|   凡例はサイズは主に1000から4000までの範囲にあることを示す。

ggplot(diamonds, aes(x = cut, y = color)) +
  geom_count()
```

プロットの各丸のサイズは値の組み合わせごとの観測数を表しています。
特定のx値と特定のy値の間に強い相関があるとき、共変動は現れます。

これら変数間の関係を探索するもう一つのアプローチは、dplyrを使ってカウントを計算することです。

```{r}
diamonds |> 
  count(color, cut)
```

それから、`geom_tile()`で外観属性fillを使って可視化します。

```{r}
#| fig-alt: |
#|   ダイアモンドのcut対colorのタイル・プロット。
#|   各タイルはcut/colorを表しており、そこでの観測数に従って
#|   色付けされている。
#|   cutで一番多いのはIdealで、cut/colorで一番多いのはIdeal/G
#|   、一番少ないのはFair/J。

diamonds |> 
  count(color, cut) |>  
  ggplot(aes(x = color, y = cut)) +
  geom_tile(aes(fill = n))
```

カテゴリ変数に順序がないのなら、興味深いパターンをより分かりやすくするために、 seriationパッケージを使って、行と列を同時に並べ直したいかもしれません。
さらに大きなプロットでは、heatmaplyパッケージを使って、インターアクティブなプロットを作成したいかもしれません。

#### 練習問題

1.  color内のcut分布、あるいは、cut内のcolor分布をより明確に示すには、上記のcountデータセットの尺度 scale をどう変更しますか？

2.  `color`を外観属性`x`に、`cut`を外観属性`fill`にマップして、セグメントに分けた棒グラフを描いたら、どんな違った洞察がデータから得られるか？
    各セグメントに入るカウントを計算しなさい。

3.  dplyrと`geom_tile()`を一緒に使って、航空便の平均出発遅延時間が目的地と月の組み合わせごとにどう異なるか探索しなさい。
    プロットを読みづらくしているのは何か？
    どうすれば改良できる？

### 2つの数値変数

2つの数値変数間の共変動を可視化する素晴らしい方法を既に見ています。
そう、`geom_point()`を使った散布図です。
共変動を点のパターンとして見ることができます。
例えば、ダイアモンドのカラットの大きさと価格の間には、カラットが増えるほど価格も上昇するという正の関係が見えます。
関係は指数関数的です。

```{r}
#| dev: "png"
#| fig-alt: |
#|   価格、対、カラットの散布図。
#|   関係は正で、いくらか強く、指数関数的。

ggplot(smaller, aes(x = carat, y = price)) +
  geom_point()
```

(本セクションでは、大抵のダイアモンドにフォーカスするために、3カラットより小さいダイアモンドの`smaller`データセットを使います)

データセットの規模が大きくなると、点のオーバープロットがはじまって、真っ黒に積み重なって、2次元スペースでのデータ密度の違いが判断しづらくなり、トレンドを見つけるのが困難になるので、散布図は役に立たなくなります。
この問題を直す方法を一つ既に見ています。外
観属性`alpha`を使って、透明度を加えるのです。

```{r}
#| dev: "png"
#| fig-alt: |
#|   価格、対、カラットの散布図。
#|   関係は正で、いくらか強く、指数関数的。
#|   点には透明度があり、点の数が他の場所より多いクラスターを示している。
#|   最も明白なクラスターは、1、1.5、2カラットのダイアモンド。

ggplot(smaller, aes(x = carat, y = price)) + 
  geom_point(alpha = 1 / 100)
```

しかし、とても大きなデータセットだと、透明度を使うのは難しいかもしれません。
他の解決策はビンを使うことです。
ここまでに、`geom_histogram()`と`geom_freqpoly()`を使って、1次元でビン詰めしました。
ここでは、`geom_bin2d()`と`geom_hex()`を使って、2次元でビン詰めする方法を学びます。

`geom_bin2d()`と`geom_hex()`は、座標面を2次元のビンに分け、ビンごとに入る点の数を表示するため色塗りします。
`geom_bin2d()`は長方形のビンを作ります。
`geom_hex()`は六角形のビンを作ります。
`geom_hex()`を使うには、hexbinパッケージをインストールする必要があります。

```{r}
#| layout-ncol: 2
#| fig-width: 3
#| fig-alt: |
#|   プロット1: price対caratの密度プロットで、長方形のビン。
#|   プロット2: price対caratのプロットで、六角形のビン。
#|   どちらのプロットも、小さいカラットと低価格が最もダイアモンドの密度が
#|   高いことを示す。

ggplot(smaller, aes(x = carat, y = price)) +
  geom_bin2d()

# install.packages("hexbin")
ggplot(smaller, aes(x = carat, y = price)) +
  geom_hex()
```

もう一つのオプションは、一つの連続変数をビン詰めして、カテゴリ変数のようにすることです。
そうすれば、学習済みのカテゴリ変数にと連続変数の組み合わせの可視化テクニックが使えます。
例えば、`carat`をビン詰めして、グループごとにボックスプロットを表示します。

```{r}
#| fig-alt: |
#|   caratごとの価格の横並びボックスプロット。
#|   各ボックスプロットは、重さが0.1カラット間隔のダイアモンドを表す。
#|   これらのボックスプロットから、カラットが増えるほど、価格の中央値も
#|   上昇することが分かる。
#|   加えて、1.5カラット以下のダイアモンドは、右に延びた価格分布で、
#|   1.5から2カラットのダイアモンドは、ほぼ左右対称な価格分布で、
#|   それ以上に重いダイアモンドは、左に延びた価格分布になっている。
#|   外れ値は、安価で小さいダイアモンドでは上方、つまり、より高価な方に、
#|   大きなダイアモンドでは下方にある。

ggplot(smaller, aes(x = carat, y = price)) + 
  geom_boxplot(aes(group = cut_width(carat, 0.1)))
```

上で使った`cut_width(x, width)`は、`x`を`width`で指定した幅のビンに分けます。
デフォルトでは、観測数が違っても、ボックスプロットは (外れ値の数を除くと) ほぼ同じ形になるので、ボックスプロットごとに点の数が違うことは分かりません。
分かるようにする一つの方法は、`varwidth = TRUE`と設定して、ボックスプロットの幅を点の数に比例するようにすることです。

#### 練習問題

1.  条件付き分布を要約するのに、ボックスプロットの替わりに、頻度ポリゴンを使うこともできる。
    `cut_width()`対`cut_number()`で検討する必要があることは何か？
    `carat`と`price`の2次元分布の可視化にどう影響するか？

2.  `price`で区切って、`carat`の分布を可視化しなさい。

3.  小さなダイアモンドに比べて、とても大きいダイアモンドの価格分布はどう違うか？
    予想通りか、驚きか？

4.  学習したテクニックの2つを組み合わせて、cut、carat、priceの組み合わさった分布を可視化しなさい。

5.  2次元のプロットは、1次元のプロットでは見えなかった外れ値を明らかにする。
    例えば、以下プロットでは、`x`値と`y`値を別々に見れば正常に見えるが、`x`値と`y`値の組み合わせでは異常で外れ値となっている点がいくつかある。
    ビン詰めのプロットよりも散布図の方が、このケースでは良い表示になっている理由は何か？

    ```{r}
    #| eval: false
    diamonds |> 
      filter(x >= 4) |> 
      ggplot(aes(x = x, y = y)) +
      geom_point() +
      coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))
    ```

6.  `cut_width()`を使って同じ幅の箱を作る替わりに、`cut_number()`を使えばほぼ同じ数の点を含む箱を作れる。
    このアプローチの長所と短所は何？

    ```{r}
    #| eval: false
    ggplot(smaller, aes(x = carat, y = price)) + 
      geom_boxplot(aes(group = cut_number(carat, 20)))
    ```

## パターンとモデル

2変数間に組織的な関係が存在するなら、データにパターンが現れます。
パターンを見つけたら、以下を尋ねてください。

-   このパターンは偶然のせい (つまり、たまたま)？

-   パターンがほのめかす関係をどう記述できるか？

-   パターンがほのめかす関係はどれほど強いか？

-   他にどんな変数がこの関係に影響している可能性があるか？

-   データのサブグループごとに見ると、関係は変化するか？

データのパターンは関係についての手ががりを提供しています。
つまり、共変動を明らかにしています。
変動を不確実性を生む現象と考えるなら、共変動はそれを減じる現象です。
2変数がそろって変動するなら、一方の変数の値を使って、もう一方の変数の値をより良く予測できます。
共変動が因果関係 (特別なケースです) のせいであれば、一方の変数の値を使って、もう一方の変数の値を制御できます。

モデルはデータからパターンを引き出す道具です。
例えば、diamondsデータを検討してみましょう。
cutとprice間の関係を理解することは困難です。c
utとcarat、caratとpriceが緊密に関連しているからです。
モデルを使えば、caratとprice間のとても強い関係を除いて、残った微妙な点を探索することができます。
以下コードは`carat`から`price`を予測するモデルをフィットして、残差 (予測値と実績値との差) を計算しています。
残差は、カラットの影響を除いた後の、ダイアモンド価格を見せてくれます。
`price`と`carat`はそのままの値を使うのではなく、log変換してから、log変換後の値にモデルをフィットしています。
それから、残差を指数化して、元の値の尺度に戻しています。

```{r}
#| message: false
#| dev: "png"
#| fig-alt: |
#|   残差、対、ダイアモンドのカラットの散布図。
#|   x軸は0から5、y軸は0から4近くの範囲。
#|   多くのデータは、低カラット、低残差辺りにクラスターになっている。
#|   カラットが増えると残差が減ることを示す、明確な曲線パターンがある。

library(tidymodels)

diamonds <- diamonds |>
  mutate(
    log_price = log(price),
    log_carat = log(carat)
  )

diamonds_fit <- linear_reg() |>
  fit(log_price ~ log_carat, data = diamonds)

diamonds_aug <- augment(diamonds_fit, new_data = diamonds) |>
  mutate(.resid = exp(.resid))

ggplot(diamonds_aug, aes(x = carat, y = .resid)) + 
  geom_point()
```

いったんcaratとprice間の強い関係を除いてしまえば、cutとprice間の予期した通りの関係、つまり、同じ大きさのダイアモンドなら高品質なほど高価という関係が見られます。

```{r}
#| fig-alt: |
#|   cutごとに横並びの残差のボックスプロット。
#|   x軸は (FairからIdealまでの) さまざまなcutを表し、
#|   y軸は0から4近くまでの範囲。
#|   中央値は、ほぼ0.75から1.25までにあるが、高品質ほど高い。
#|   残差の分布はそれぞれ、右に延びていて、高い方に外れ値がある。

ggplot(diamonds_aug, aes(x = cut, y = .resid)) + 
  geom_boxplot()
```

本書ではモデルは議論していません。デ
ータを手懐けたり、プログラムしたりする道具を身に付ける前では、モデルが何で、どう機能するのか理解することは困難だからです。

## まとめ

本章では、データ内の変動を理解する助けとなるさまざまな道具を学習しました。
いっときに一つの変数で機能するテクニックや、変数のペアで機能するテクニックを見てきました。
データに何十、何百と変数がある場合、これでは足りないように思えますが、これらはその上に、他の全てのテクニックが構築されている基礎となっています。

次章では、結果を伝達するために使える道具にフォーカスします。
