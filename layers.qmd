# レイヤー {#sec-layers}

```{r}
#| echo: false

source("_common.R")
```

## はじめに

@sec-data-visualization で学んだことは、散布図、棒グラフ、ボックスプロットの作り方だけではありません。
ggplot2を使って*どんな*タイプのプロットでも作るのに使える基礎を学んだのです。

本章では、その基礎を拡張して、レイヤー化されたグラフィックの文法を学習します。
外観属性のマッピング、幾何オブジェクト、ファセットにより深く潜り込むところからはじめます。
次に、ggplot2がプロット作成中に袖の下で行っている統計変換を学習します。
棒グラフの棒の高さやボックスプロット中の中央値などの、プロットに必要な新しい値を計算するために、これらの変換が使われます。
プロットにおいてgeomの表示され方を修正する、position調整も学習します。
最後に、coordinateシステムを簡潔に紹介します。

これらレイヤーのそれぞれの全ての関数、オプションはカバーしませんが、ggplot2が提供する最も大切で最もよく使われている機能は網羅しますし、ggplot2を拡張するパッケージも紹介します。

### 用意するもの

本章はggplot2にフォーカスします。
本章で使用するデータセット、ヘルプページ、関数にアクセスできるよう、以下コードを実行してtidyverseをロードします。

```{r}
#| label: setup
#| message: false

library(tidyverse)
```

## 外観属性マッピング

> "図の最大の価値は、予期していなかったことに気付かせてくれることにある。" --- John Tukey

ggplot2パッケージにバンドルされている`mpg`データフレームには、`r mpg |> distinct(model) |> nrow()`車種のモデルについて、`r nrow(mpg)`個の観測 が入っています。

```{r}
mpg
```

`mpg`には以下の変数が含まれている。

1.  `displ`: 車の排気量をリッターで表記。
    数値変数。

2.  `hwy`: 高速道路での車の燃料効率をガロン当たりマイル (mpg) で表記。
    同じ距離を走るのに、低効率車は高効率車よりも多くの燃料を消費する。
    数値変数。

3.  `class`: 車の種類。
    カテゴリ変数。

`class`ごとに`displ`と`hwy`の間の関係を可視化するところからはじめましょう。
数値変数を外観属性`x`と`y`にマップして、カテゴリ変数を`color`か`shape`の外観属性にマップした散布図で可視化できます。

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-alt: |
#|   2つの散布図が並んでいる。どちらも、車の高速道路での燃料効率、対、
#|   排気量を可視化、負の相関を表している。
#|   左のプロットでは、 classは外観属性colorにマップされ、その結果、
#|   classごとに色が違っている。
#|   右のプロットでは、 classは外観属性shapeにマップされ、その結果、
#|   suvを除いてclassごとに形が違っている。
#|   どちらのプロットにも凡例があり、colorもしくはshapeとclass変数間の
#|   マッピングを表している。

# 左
ggplot(mpg, aes(x = displ, y = hwy, color = class)) +
  geom_point()

# 右
ggplot(mpg, aes(x = displ, y = hwy, shape = class)) +
  geom_point()
```

`class`を`shape`にマップすると、2つ警告が出て来ます。

> 1: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to discriminate; you have 7.
> Consider specifying shapes manually if you must have them.
>
> 2: Removed 62 rows containing missing values (`geom_point()`).

デフォルトではggplot2が使えるshapeは6つまでなので、外観属性shapeを使うと7つ目以降のグループはプロットされません。
2つ目の警告も関係があります。デ
ータセットには62個のSUVがあり、それらがプロットされていないのです。

同様に、`class`を外観属性`size`や`alpha`にマップすることもできます。
それぞれ、点のサイズと透明度を制御します。

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-alt: |
#|   2つの散布図が並んでいる。どちらも、車の高速道路での燃料効率、対、
#|   排気量を可視化、負の相関を表している。
#|   左のプロットでは、 classは外観属性sizeにマップされ、その結果、
#|   classごとにサイズが違っている。
#|   右のプロットでは、 classは外観属性alphaにマップされ、その結果、
#|   classごとに透明度が違っている。
#|   どちらのプロットにも凡例があり、sizeもしくはalphaの水準と
#|   class変数間の水準のマッピングを表している。

# 左
ggplot(mpg, aes(x = displ, y = hwy, size = class)) +
  geom_point()

# 右
ggplot(mpg, aes(x = displ, y = hwy, alpha = class)) +
  geom_point()
```

どちらにも同様の警告が出ています。

> Using alpha for a discrete variable is not advised.

`class`のような順番のない離散変数 (カテゴリ変数) を、`size`や`alpha`のような順番のある外観属性にマップすることは、一般にお薦めできません。実
際には存在しない順位を示唆してしまうからです。

外観属性へのマップを済ませば、後はggplot2が面倒を見てくれます。
外観属性に使うのが理にかなうscaleを選択して、水準と値の間のマッピングを説明する凡例を構築してくれます。
外観属性xとyについては、ggplot2は凡例は作成しませんが、目盛りとラベルの付いた軸を作成してくれます。
軸は凡例と同じ情報を提供してくれます。水
準と値の間のマッピングを説明してくれているのです。

外観を決めるのに変数マッピングに頼る替わりに、(`aes()`の*外側*で) geom関数の引数として、自分の手でgeomの可視属性を設定することもできます。
例えば、プロットの全ての点を青色にできます。

```{r}
#| fig-alt: |
#|   車の高速道路での燃料効率、対、
#|   排気量の散布図。負の相関を表している。全ての点が青色。

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(color = "blue")
```

ここでは、色は変数についての情報を伝えておらず、単にプロットの外観を変えているだけです。
外観属性ごとに意味がある値を選ぶ必要があります。

-   色の名前は文字列で設定。例えば、`color = "blue"`。
-   点のサイズはミリで設定。例えば、`size = 1`。
-   点の形は数値で設定。例えば、`shape = 1`だと、@fig-shapes の1番の形に。

```{r}
#| label: fig-shapes
#| echo: false
#| warning: false
#| fig.asp: 0.364
#| fig-align: "center"
#| fig-cap: |
#|   Rには組み込み形が26個あり、数値で特定されている。重複して
#|   見えるものがいくつかある。例えば、0、15、22はどれも四角。
#|   違いは外観属性`color`と`fill`の相互交流にある。中が空の形 (0--14) は
#|   境界線が`color`で決まり、境界線のない黒塗りの形 (15--18) は塗り色が
#|   `color`で決まり、境界線のある黒塗りの形 (19--20) は境界線、塗り色
#|   ともに`color`で決まり、
#|   境界線のある赤塗りの形 (21--25) は境界線が`color`で
#|   塗り色は`fill`で決まる。似た形が隣り合うよう形には番号が付けられている。
#| fig-alt: |
#|   形とそれを表す数値のマッピング。
#|   0 - square open, 
#|   1 - circle open, 2 - triangle open, 3 - plus, 4 - cross, 5 - diamond open, 
#|   6 - triangle down open, 7 - square cross, 8 - asterisk, 9 - diamond plus, 
#|   10 - circle plus, 11 - star, 12 - square plus, 
#|   13 - circle cross, 14 - square triangle, 15 - square, 
#|   16 - circle small, 17 - triangle, 18 - diamond, 
#|   19 - circle, 20 - bullet, 21 - circle filled, 
#|   22 - square filled, 23 - diamond filled, 24 - triangle filled, 
#|   25 - triangle down filled.

shapes <- tibble(
  shape = c(0, 1, 2, 5, 3, 4, 6:19, 22, 21, 24, 23, 20, 25),
  x = (0:25 %/% 5) / 2,
  y = (-(0:25 %% 5)) / 4
)
ggplot(shapes, aes(x, y)) + 
  geom_point(aes(shape = shape), size = 5, fill = "red") +
  geom_text(aes(label = shape), hjust = 0, nudge_x = 0.15) +
  scale_shape_identity() +
  expand_limits(x = 4.1) +
  scale_x_continuous(NULL, breaks = NULL) + 
  scale_y_continuous(NULL, breaks = NULL, limits = c(-1.2, 0.2)) + 
  theme_minimal() +
  theme(aspect.ratio = 1/2.75)
```

ここまでは、point geomを使う際に、散布図でマップする、あるいは、設定する外観属性を議論してきました。
可能な外観属性全てについてもっと学習するには、aesthetic specifications vignette <https://ggplot2.tidyverse.org/articles/ggplot2-specs.html> に当たってください。

プロットに使える特定の外観属性はデータを表すのに使うgeomごとに異なります。
次章では、様々なgeomにより深く潜り込みます。

### 練習問題

1.  `hwy`対`displ`の散布図を描きなさい。点
    はピンク色で塗った三角にすること。

2.  以下のコードでプロットすると、点が青色にならないのはなぜか？

    ```{r}
    #| fig-show: hide
    #| fig-alt: |
    #|   車の高速道路での燃料効率、対、
    #|   排気量の散布図。負の相関を表している。全ての点が赤色。
    #|   blueという言葉にマップされた赤色の点を、凡例は示している。

    ggplot(mpg) + 
      geom_point(aes(x = displ, y = hwy, color = "blue"))
    ```

3.  外観属性`stroke`の役割は？
    どの形でなら機能するか？
    (ヒント：`?geom_point`)

4.  `aes(color = displ < 5)`のように、外観属性を変数名以外のものにマップしたら、どうなるか？
    xとyも指定して試してみよ。

## 幾何オブジェクト {#sec-geometric-objects}

これら2つのプロットはどう似ているでしょうか？

```{r}
#| echo: false
#| message: false
#| layout-ncol: 2
#| fig-width: 3
#| fig-alt: |
#|   2つのプロット。左側は、車の高速道路での燃料効率、対、排気量の散布図。
#|   右側は、この2変数間の関係の軌道に沿う滑らかな曲線を示す。
#|   滑らかな曲線の周りに信頼区間も表示されている。

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point()

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_smooth()
```

どちらのプロットも、x変数、y変数は同じで、同じデータを表しています。
しかし、プロットは同じではありません。
データを表すのに、異なる幾何オブジェクト (geom) を使っているからです。
左側のプロットは point geom を、右側のプロットはデータにフィットされた滑らかな曲線である smooth geom を使っています。

プロットのgeomを変更するには、`ggplot()`に追加するgeom関数を変更します。
例えば、上のプロットを作成するには、以下コードが使えます。

```{r}
#| fig-show: hide

# 左
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point()

# 右
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_smooth()
```

ggplot2の全てのgeom関数は`mapping`引数を取り、geomレイヤーでローカルにか、`ggplot()`レイヤーでグローバルにか、指定します。
しかし、全ての外観属性がどのgeomでも機能するわけではありません。
点の形は設定できますが、線の"shape"は設定できません。
やってみると、ggplot2はその外観属性は黙って無視します。
他方で、線にはlinetypeを設定*できます*。
linetypeにマップした変数のユニークな値ごとに違った線種で、`geom_smooth()`は線を描きます。

```{r}
#| message: false
#| layout-ncol: 2
#| fig-width: 3
#| fig-alt: |
#|   車の高速道路での燃料効率、対、排気量の2つのプロット。
#|   データは滑らかな曲線で表されている。左側では、滑らかな曲線が3つあるが、
#|   線種は同じ。右側では、滑らかな曲線が3つあり、駆動方式ごとに線種が
#|   異なる (実線、破線、長めの破線) 。どちらのプロットでも、
#|   滑らかな曲線の周りに信頼区間も表示されている。

# 左
ggplot(mpg, aes(x = displ, y = hwy, shape = drv)) + 
  geom_smooth()

# 右
ggplot(mpg, aes(x = displ, y = hwy, linetype = drv)) + 
  geom_smooth()
```

ここでは、`geom_smooth()`は駆動方式`drv`の値に基づいて車を3つの線に分けています。
一つの線は`4`値の全ての点を、一つの線は`f`値の全ての点を、そして、もう一つの線は`r`値の全ての点を描写しています。
ここで、`4`は四輪駆動、`f`は前輪駆動、`r`は後輪駆動を表しています。

奇妙に聞こえるようなら、より明確になるように、生のデータの上に線を重ね、`drv`ごとに点も線も色を変えることもできます。

```{r}
#| message: false
#| fig-alt: |
#|   車の高速道路での燃料効率、対、排気量のプロット。データは
#|   (駆動方式ごとに異なる色の) 点と (駆動方式ごとに色と線種が異なる)
#|   滑らかな曲線で表されている。
#|   滑らかな曲線の周りに信頼区間も表示されている。

ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + 
  geom_point() +
  geom_smooth(aes(linetype = drv))
```

同じグラフに2つのgeomが入っていますね。

`geom_smooth()`などの多くのgeomは、複数行のデータを表示するのに単一の幾何オブジェクトを使います。
これらのgeomでは、外観属性`group`をカテゴリ変数にマップすることで、複数のオブジェクトを描けます。
グループ化変数のユニークな値ごとに、別々のオブジェクトをggplot2は描きます。
実際には、これらのgeomで (例えば、`linetype`のような) 外観属性を離散変数にマップすれば、ggplot2は自動的にデータをグループ化します。
この機能に頼るのが便利です。外
観属性`group`自身は、geomに凡例もこれといった特徴も追加しないのですから。

```{r}
#| layout-ncol: 3
#| fig-width: 3
#| fig-asp: 1
#| message: false
#| fig-alt: |
#|   3つのプロット。どれも、y軸に車の高速道路での燃料効率、
#|   x軸に排気量。データは滑らかな曲線で表されている。
#|   左のプロットはこの2変数だけ、真ん中のプロットは駆動方式ごとに別々の
#|   3つの滑らかな曲線、右のプロットはさらに曲線の色も別々にしている。
#|   滑らかな曲線の周りに信頼区間も表示されている。

# 左
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth()

# 中
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth(aes(group = drv))

# 右
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth(aes(color = drv), show.legend = FALSE)
```

マッピングをgeom関数の中に置けば、ggplot2はそのレイヤーだけのローカルなマッピングとして扱います。
グローバルなマッピングを拡張、または、上書きして、*そのレイヤーだけの*マッピングとして使うのです。
こうすることで、異なるレイヤーでは異なる外観属性を表示することが可能になっています。

```{r}
#| message: false
#| fig-alt: |
#|   車の高速道路での燃料効率、対、排気量の散布図。点は車のクラスごとに
#|   異なる色なっている。車の高速道路での燃料効率、対、排気量の関係の
#|   軌道に沿う滑らかな曲線が、その周りの信頼区間と一緒に、
#|   重ねられている。

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(aes(color = class)) + 
  geom_smooth()
```

同じアイディアを使って、レイヤーごとに別々の`data`を指定することもできます。
ここでは、二座席車を赤い点とそれを囲む丸でハイライトしています。
`geom_point()`の中でローカルなdata引数を指定することで、`ggplot()`の中のグローバルなdata引数を、そのレイヤー限定で上書きしています。

```{r}
#| message: false
#| fig-alt: |
#|   車の高速道路での燃料効率、対、排気量の散布図。二座席車だけは、
#|   点は赤く、丸で囲まれている。

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_point(
    data = mpg |> filter(class == "2seater"), 
    color = "red"
  ) +
  geom_point(
    data = mpg |> filter(class == "2seater"), 
    shape = "circle open", size = 3, color = "red"
  )
```

幾何オブジェクト geom は、ggplot2の根本的な構成単位です。
geomを変更するとプロットの外観を完全に変換できますし、違ったgeomからデータの違った特徴が明らかになることがあります。
例えば、以下のヒストグラムと密度プロットからは高速道路での燃料効率の分布には山が2つあって右に長く伸びていることが分かる一方、ボックスプロットからは外れ値らしきものが2つあることが分かります。

```{r}
#| layout-ncol: 3
#| fig-width: 3
#| fig-alt: |
#|   3つのプロット。高速道路での燃料効率の
#|   ヒストグラム、密度プロット、ボックスプロット。

# 左
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(binwidth = 2)

# 中
ggplot(mpg, aes(x = hwy)) +
  geom_density()

# 右
ggplot(mpg, aes(x = hwy)) +
  geom_boxplot()
```

ggplot2は40を超えるgeomを提供していますが、作成可能な全てのプロットをカバーしてはいません。
ggplot2が提供するgeomとは違ったgeomが必要なら、まず誰か他の人が既に拡張パッケージを作成してくれていないか確認することをお薦めします (サンプルとして、<https://exts.ggplot2.tidyverse.org/gallery/>を見てみてください)。
例えば、**ggridges**パッケージ ([https://wilkelab.org/ggridges](https://wilkelab.org/ggridges/){.uri}) は、ridgelineプロットを作成するのに役立ちます。カ
テゴリ変数の別々の水準ごとに数値変数の密度を可視化するのに使えるプロットです。
以下のプロットでは、新しいgeom (`geom_density_ridges()`) を使うだけでなく、同じ変数を複数の外観属性に (`drv`を`y`、`fill`、`color`に) マップし、密度曲線を透明にするために外観属性を (`alpha = 0.5`と) 設定しています。

```{r}
#| fig-asp: 0.33
#| fig-alt: 
#|   車の高速道路での燃料効率の密度曲線を、後輪駆動、前輪駆動、
#|   四輪駆動で別々にプロット。後輪駆動と四輪駆動では、分布には
#|   山が2つありほぼ左右対称。前輪駆動での分布は山が1つで右に
#|   長く伸びている。

library(ggridges)

ggplot(mpg, aes(x = hwy, y = drv, fill = drv, color = drv)) +
  geom_density_ridges(alpha = 0.5, show.legend = FALSE)
```

ggplot2が提供する全てのgeomと関数を網羅的にざっと眺めるには、referenceページ<https://ggplot2.tidyverse.org/reference>をお薦めします。
個々のgeomを深く学習するには、ヘルプを使いましょう (例えば、`?geom_smooth`とします)。

### 練習問題

1.  線グラフを描くのに使うgeomは何？
    ボックスプロットでは何？
    ヒストグラムでは何？
    領域グラフでは何？

2.  ここまでの本章で説明もせずに以下のように`show.legend`を使っている。

    ```{r}
    #| fig-show: hide
    #| message: false

    ggplot(mpg, aes(x = displ, y = hwy)) +
      geom_smooth(aes(color = drv), show.legend = FALSE)
    ```

    ここでの`show.legend = FALSE`の役目は？
    それを削除するとどうなるか？
    ここまでの本章でそれを使った理由は何だと思う？

3.  `geom_smooth()`での`se`引数の役割は何？

4.  以下のグラフを生成するのに必要なRコードを再現しなさい。
    ちなみに、プロットで使われているカテゴリ変数は全て`drv`。

    ```{r}
    #| echo: false
    #| message: false
    #| layout-ncol: 2
    #| fig-width: 3
    #| fig-alt: |
    #|   本図には6つの散布図があり、3x2区画に並べられている。
    #|   全てのプロットで、y軸は車の高速道路での燃料効率で、x軸は排気量。
    #|   第1のプロットでは、全ての点は黒色で、滑らかな曲線1本が重なる。
    #|   第2のプロットでも、 全ての点は黒色で、滑らかな曲線が重なるが、
    #|   滑らかな曲線は駆動方式ごとの3本。
    #|   第3のプロットでは、さらに点と線が駆動方式ごとに異なる色に。
    #|   第4のプロットでは、点は駆動方式ごとに異なる色だが、
    #|   線は全体にフィットした1本に。
    #|   第5のプロットでは、点は駆動方式ごとに異なる色で、線は
    #|   駆動方式ごとの3本で線種が異なる。
    #|   最後に、第6のプロットでは、点は駆動方式ごとに異なる色で周りに厚い
    #|   境界線がある。線はない。

    ggplot(mpg, aes(x = displ, y = hwy)) + 
      geom_point() + 
      geom_smooth(se = FALSE)
    ggplot(mpg, aes(x = displ, y = hwy)) + 
      geom_smooth(aes(group = drv), se = FALSE) +
      geom_point()
    ggplot(mpg, aes(x = displ, y = hwy, color = drv)) + 
      geom_point() + 
      geom_smooth(se = FALSE)
    ggplot(mpg, aes(x = displ, y = hwy)) + 
      geom_point(aes(color = drv)) + 
      geom_smooth(se = FALSE)
    ggplot(mpg, aes(x = displ, y = hwy)) + 
      geom_point(aes(color = drv)) +
      geom_smooth(aes(linetype = drv), se = FALSE)
    ggplot(mpg, aes(x = displ, y = hwy)) + 
      geom_point(size = 4, color = "white") + 
      geom_point(aes(color = drv))
    ```

## ファセット

@sec-data-visualization で、プロットをサブプロットに分け、それぞれがデータをカテゴリ変数に基づいて分けたサブセットを表示するファセットを、`facet_wrap()`を使って学びました。

```{r}
#| fig-alt: |
#|   車の高速道路での燃料効率、対、排気量の散布図。
#|   エンジンのシリンダ数ごとにファセットされ、2行にわたって表示。

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_wrap(~cyl)
```

2つの変数の組み合わせでファセットするには、`facet_wrap()`から`facet_grid()`に切り替えます。
`facet_grid()`の第1引数はやはり式ですが、ただ両側に変数がある`rows ~ cols`の形を取ります。

```{r}
#| fig-alt: |
#|   車の高速道路での燃料効率、対、排気量の散布図。
#|   エンジンのシリンダ数ごとに4列、駆動方式ごとに3行に分けて
#|   ファセットされている。結果、4x3区画で12個のファセットになっている。
#|   観測がないファセットもある。四輪駆動の5シリンダ、前輪駆動の4、5シリンダ
#|   には観測がない。

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_grid(drv ~ cyl)
```

デフォルトでは、各ファセットのx軸とy軸の尺度と範囲は同じです。
ファセット間でデータを比較したいときにはそれで良いのですが、各ファセット内の関係をより見やすく可視化したいときには邪魔になります。
ファセット関数の中の`scales`引数を`"free"`に設定することで、x軸とy軸ともに尺度を別々に、`"free_x"`とすればx軸だけの尺度を別々に、`"free_y"`とすればy軸だけの尺度を別々にできます。
Setting the `scales` argument in a faceting function to `"free_x"` will allow for different scales of x-axis across columns, and `"free_y"` will allow for different scales on y-axis across rows, and `"free"` will allow both.

```{r}
#| fig-alt: |
#|   車の高速道路での燃料効率、対、排気量の散布図。
#|   エンジンのシリンダ数ごとに4列、駆動方式ごとに3行に分けて
#|   ファセットされている。結果、4x3区画で12個のファセットになっている。
#|   観測がないファセットもある。四輪駆動の5シリンダ、前輪駆動の4、5シリンダ
#|   には観測がない。同じ行のファセットはy軸の尺度が同じで、
#|   同じ列のファセットはx軸の尺度が同じ。

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_grid(drv ~ cyl, scales = "free")
```

### 練習問題

1.  連続値変数でファセットしたらどうなるか？

2.  `facet_grid(drv ~ cyl)`を使った上のプロットで空のセルが意味するのは何か？
    以下コードを実行しなさい。
    出力されたプロットととの関係は？

    ```{r}
    #| fig-show: hide

    ggplot(mpg) + 
      geom_point(aes(x = drv, y = cyl))
    ```

3.  以下コードはどんなプロットを作成するか？
    `.`の役目は？

    ```{r}
    #| fig-show: hide

    ggplot(mpg) + 
      geom_point(aes(x = displ, y = hwy)) +
      facet_grid(drv ~ .)

    ggplot(mpg) + 
      geom_point(aes(x = displ, y = hwy)) +
      facet_grid(. ~ cyl)
    ```

4.  このセクションの最初のファセットされたプロットを見なさい。

    ```{r}
    #| fig-show: hide

    ggplot(mpg) + 
      geom_point(aes(x = displ, y = hwy)) + 
      facet_wrap(~ cyl, nrow = 2)
    ```

    外観属性colorの替わりにファセットを使う長所は何？
    欠点は？
    データセットが大きくなるにつれて、バランスはどう変わりますか？

5.  `?facet_wrap`を読みなさい。
    `nrow`の役割は？
    `ncol`の役割は？
    個々のパネルのレイアウトを制御するオプションは他に何があるか？
    `facet_grid()`には引数に`nrow`も`ncol`もない理由は？

6.  駆動方式ごとに排気量 (`displ`) を比較するのは、以下プロットのどちらが容易？
    ファセットする変数を行に置くべきときと、列に置くべきときについて、何が言えるか？

    ```{r}
    #| fig-show: hide
    #| message: false

    ggplot(mpg, aes(x = displ)) + 
      geom_histogram() + 
      facet_grid(drv ~ .)

    ggplot(mpg, aes(x = displ)) + 
      geom_histogram() +
      facet_grid(. ~ drv)
    ```

7.  `facet_grid()`の替わりに`facet_wrap()`を使って、以下プロットを再現しなさい。
    ファセットのラベル位置を変更するにはどうする？

    ```{r}
    #| fig-show: hide

    ggplot(mpg) + 
      geom_point(aes(x = displ, y = hwy)) +
      facet_grid(drv ~ .)
    ```

## 統計変換

`geom_bar()`や`geom_col()`で描く、基本的な棒グラフを考えてみましょう。
以下プロットは`diamonds`データセットでの`cut`ごとのダイアモンドの数合計を表示しています。
`diamonds`データセットはggplot2パッケージに入っており、54,000個程度のダイアモンドの`price`、`carat`、`color`、`clarity`、`cut`などの情報を含んできます。
以下プロットは、高品質カットのダイアモンドの方が低品質カットのものより多いことを表しています。

```{r}
#| fig-alt: |
#|   ダイアモンドのカット水準ごとのカウントの棒グラフ。ざっと、1500個が 
#|   Fair、5000個がGood、12000個がVery Good、14000個がPremium、 
#|   そして、22000個がIdeal。

ggplot(diamonds, aes(x = cut)) + 
  geom_bar()
```

x軸には`cut`という`diamonds`からの変数が表示されています。
y軸にはcountと表示されていますが、そんな変数は`diamonds`にはありません！
一体どこから出て来たのでしょうか？
散布図のような多くのグラフは、データセットのデータをそのままプロットします。
棒グラフのようなその他のグラフは、プロットする新しい変数を計算します。

-   棒グラフ、ヒストグラム、頻度ポリゴンは、データをビンに詰めから、各ビンの中に入っている点の数、つまり、ビン・カウントをプロットします。

-   滑らかな曲線は、データにモデルをフィットさせてから、モデルからの予測をプロットします。

-   ボックスプロットは、分布の5つの数値要約を計算してから、特別な形式の箱の格好で要約を表示します。

グラフ用に新しい変数を計算するアルゴリズムのことを、統計変換 (statistical transformation) 、略して**stat**と呼びます。
@fig-vis-stat-bar は、`geom_bar()`を使って、この過程がどう機能するのか示しています。

```{r}
#| label: fig-vis-stat-bar
#| echo: false
#| out-width: "100%"
#| fig-cap: |
#|   棒グラフを作成するには、まず生のデータからはじめて、次に
#|   棒ごとの観測数をカウントして集計、最後にこれらの計算された変数を
#|   プロットの外観属性にマップする。
#| fig-alt: |
#|   図は棒グラフ作成の3つのステップを実演している。
#|   ステップ1：geom_bar()は、diamondsデータセットを読み込む。
#|   ステップ2：geom_bar()は、データを変換して、
#|   cut値とcountのデータセットであるcount statにする。
#|   ステップ3：geom_bar()は、変換後のデータを使ってプロットを構築する。
#|   cutはx軸に、countはy軸にマップされる。

knitr::include_graphics("images/visualization-stat-bar.png")
```

geomがどのstatを使っているかは、`stat`引数のデフォルト値を調べれば分かります。
例えば、`?geom_bar`とすれば、`stat`引数のデフォルト値は"count"であると出ますので、`geom_bar()`は`stat_count()`を使っていると分かります。
`stat_count()`は`geom_bar()`と同じページにヘルプがあります。
下へスクロールすると、"Computed variables"のセクションで、それが2つの新しい変数`count`と`prop`を計算していることが説明されています。

geomごとにデフォルトのstatがあり、statごとにデフォルトのgeomがあります。
そのおかげで、通常は根底にある統計変換について悩むことなくgeomを使えます。
しかし、明示的にstatを使う必要が出てくる3つの理由があります。

1.  statをデフォルトから変更したいかもしれません。
    以下コードでは、`geom_bar()`のstatを (デフォルトの) countからidentityに変更しています。
    これで、y変数の生データが棒の高さにマップされます。

    ```{r}
    #| warning: false
    #| fig-alt: |
    #|   ダイアモンドのカット水準ごとのカウントの棒グラフ。ざっと、1500個が 
    #|   Fair、5000個がGood、12000個がVery Good、14000個がPremium、 
    #|   そして、22000個がIdeal。

    diamonds |>
      count(cut) |>
      ggplot(aes(x = cut, y = n)) +
      geom_bar(stat = "identity")
    ```

2.  外観属性にマップされる変換後の変数を、デフォルトから変更したいかもしれません。
    例えば、棒グラフでカウントではなく比率を表示したいかもしれません。

    ```{r}
    #| fig-alt: |
    #|   ダイアモンドのカット水準ごとの比率の棒グラフ。ざっと、
    #|   Fairが0.03、Goodが0.09、Very Goodが0.22、Premium 0.26、 
    #|   Idealが0.40を占める。

    ggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) + 
      geom_bar()
    ```

    statで計算できる変数を探すには、`geom_bar()`のヘルプの中の"Computed variables"というタイトルのセクションを見てください。

3.  コード内で統計変換に、より注目を集めたいかもしれません。
    例えば、xのユニークな値ごとにy値を要約する`stat_summary()`を使って、計算している要約に注目を集めたいかもしれません。

    ```{r}
    #| fig-alt: |
    #|   ダイアモンドのcut (fair、good、very good、premium、idealの各水準)
    #|   がx軸、depthがy軸のプロット。cutのカテゴリごとにdepthの最小値から
    #|   最大値まで垂直線が伸び、depthの中央値が線上の点で示されている。

    ggplot(diamonds) + 
      stat_summary(
        aes(x = cut, y = depth),
        fun.min = min,
        fun.max = max,
        fun = median
      )
    ```

ggplot2は20を超えるstatが使えるよう提供しています。
各statは関数なので、いつものやり方でヘルプを得ることができます。例
えば、`?stat_bin`とします。

### 練習問題

1.  `stat_summary()`のデフォルトgeomは何か？
    先のプロットを、stat関数ではなくgeom関数を使って描き直すには、どうするか？

2.  `geom_col()`は何をするか？
    `geom_bar()`とどう違うのか？

3.  ほとんどのgeomとstatは、たいてい上手く機能するペアになっている。
    それらペアの全リストを作成しなさい。
    共通点は何か？
    (ヒント：ヘルプを読め。)

4.  `stat_smooth()`が計算する変数は何か？
    その振る舞いを制御する引数は何か？

5.  上の棒グラフで比率を描いた際、`group = 1`と設定する必要があった。
    その理由は？
    言い換えると、以下2つのグラフのどこが問題なのか？

    ```{r}
    #| fig-show: hide

    ggplot(diamonds, aes(x = cut, y = after_stat(prop))) + 
      geom_bar()
    ggplot(diamonds, aes(x = cut, fill = color, y = after_stat(prop))) + 
      geom_bar()
    ```

## 位置調整

棒グラフに関連して、もう一つ魔法があります。
外観属性の`color`、もしくは、より役に立つ`fill`を使って、棒グラフに色を付けられます。

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-alt: |
#|   車の駆動方式の2つの棒グラフ。第1のプロットでは、
#|   棒の境界線が色付けされている。第2のプロットでは、棒が色塗りされている。
#|   棒の高さは駆動方式ごとの車の数に対応している。

# 左
ggplot(mpg, aes(x = drv, color = drv)) + 
  geom_bar()

# 右
ggplot(mpg, aes(x = drv, fill = drv)) + 
  geom_bar()
```

外観属性fillを`class`のような他の変数にマップしたらどうなるか、見てみましょう。棒
が自動的に積み上げられています。
色塗りされた長方形それぞれが、`drv`と`class`の組み合わせを表しています。

```{r}
#| fig-alt: |
#|   車の駆動方式の棒グラフで、車のクラスごとに色分けされている。
#|   棒の高さは駆動方式ごとの車の数に対応しており、
#|   色分けされた部分の高さは駆動方式ごとのクラス水準ごとの車の数に
#|   なっている。

ggplot(mpg, aes(x = drv, fill = class)) + 
  geom_bar()
```

`position`引数で指定する**位置調整**を使って、積み上げが自動的に行われています。
積み上げ (`"stack"`) が嫌なら、他の3つのオプション、`"identity"`、`"dodge"`、`"fill"`、のどれかを使えます。

-   `position = "identity"`は、グラフの文脈においてそのままの位置に、各オブジェクトを配置します。
    棒グラフでは重なってしまうので、あまり役に立ちません。
    重なっていても見えるようにするには、`alpha`を小さい値に設定して棒を少々透明にするか、`fill = NA`と設定して完全に透明にするか、しなければなりません。

    ```{r}
    #| layout-ncol: 2
    #| fig-width: 4
    #| fig-alt: |
    #|   車の駆動方式の棒グラフで、車のクラスごとに色分けされている。
    #|   色分けされた部分の高さは駆動方式ごとのクラス水準ごとの車の数に
    #|   なっている。ただ、各部分は重なっている。
    #|   第1のプロットでは、棒は透明な色に塗られている。
    #|   第2のプロットでは、棒の境界線にだけ色が付いている。

    # 左
    ggplot(mpg, aes(x = drv, fill = class)) + 
      geom_bar(alpha = 1/5, position = "identity")

    # 右
    ggplot(mpg, aes(x = drv, color = class)) + 
      geom_bar(fill = NA, position = "identity")
    ```

    位置調整をidentityとすることは、pointのような2次元geomではもっと役に立つので、そこではデフォルトになっています。

-   `position = "fill"`は、積み上げに似ていますが、積み上げ後の棒の高さを同じにします。
    グループ間の比率を比較するのが容易になります。

-   `position = "dodge"`は、オブジェクトを重ねるのではなく、すぐ*隣に*並べます。
    個々の値を比較するのが容易になります。

    ```{r}
    #| layout-ncol: 2
    #| fig-width: 4
    #| fig-alt: |
    #|   左側は、車の駆動方式の棒グラフで、車のクラスごとに色分けされている。
    #|   棒の高さは全て1。色分けされた部分の高さは、
    #|   各駆動方式内でのクラス水準別の車数の比率を表している。
    #|   右側は、車の駆動方式の棒グラフで横置きされている。
    #|   棒は駆動方式の水準でグループ化され、各グループ内での各棒は
    #|   クラス水準の車数を表している。ある駆動方式には存在するが、
    #|   他の駆動方式では存在しないクラスがある。その結果、
    #|   各グループで棒の数が異なっている。各棒の高さは駆動方式とクラス
    #|   ごとの車数を表している。

    # 左
    ggplot(mpg, aes(x = drv, fill = class)) + 
      geom_bar(position = "fill")

    # 右
    ggplot(mpg, aes(x = drv, fill = class)) + 
      geom_bar(position = "dodge")
    ```

There's one other type of adjustment that's not useful for bar charts, but can be very useful for scatterplots.
Recall our first scatterplot.
Did you notice that the plot displays only 126 points, even though there are 234 observations in the dataset?

```{r}
#| echo: false
#| fig-alt: |
#|   車の高速道路での燃料効率、対、排気量の散布図で、
#|   負の相関を表している。

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point()
```

The underlying values of `hwy` and `displ` are rounded so the points appear on a grid and many points overlap each other.
This problem is known as **overplotting**.
This arrangement makes it difficult to see the distribution of the data.
Are the data points spread equally throughout the graph, or is there one special combination of `hwy` and `displ` that contains 109 values?

You can avoid this gridding by setting the position adjustment to "jitter".
`position = "jitter"` adds a small amount of random noise to each point.
This spreads the points out because no two points are likely to receive the same amount of random noise.

```{r}
#| fig-alt: |
#|   車の高速道路での燃料効率、対、排気量の散布図で、点に揺らぎを与えている。
#|   プロットは負の相関を表している。

ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(position = "jitter")
```

Adding randomness seems like a strange way to improve your plot, but while it makes your graph less accurate at small scales, it makes your graph *more* revealing at large scales.
Because this is such a useful operation, ggplot2 comes with a shorthand for `geom_point(position = "jitter")`: `geom_jitter()`.

To learn more about a position adjustment, look up the help page associated with each adjustment: `?position_dodge`, `?position_fill`, `?position_identity`, `?position_jitter`, and `?position_stack`.

### Exercises

1.  What is the problem with the following plot?
    How could you improve it?

    ```{r}
    #| fig-show: hide

    ggplot(mpg, aes(x = cty, y = hwy)) + 
      geom_point()
    ```

2.  What, if anything, is the difference between the two plots?
    Why?

    ```{r}
    #| fig-show: hide

    ggplot(mpg, aes(x = displ, y = hwy)) +
      geom_point()
    ggplot(mpg, aes(x = displ, y = hwy)) +
      geom_point(position = "identity")
    ```

3.  What parameters to `geom_jitter()` control the amount of jittering?

4.  Compare and contrast `geom_jitter()` with `geom_count()`.

5.  What's the default position adjustment for `geom_boxplot()`?
    Create a visualization of the `mpg` dataset that demonstrates it.

## Coordinate systems

Coordinate systems are probably the most complicated part of ggplot2.
The default coordinate system is the Cartesian coordinate system where the x and y positions act independently to determine the location of each point.
There are two other coordinate systems that are occasionally helpful.

-   `coord_quickmap()` sets the aspect ratio correctly for geographic maps.
    This is very important if you're plotting spatial data with ggplot2.
    We don't have the space to discuss maps in this book, but you can learn more in the [Maps chapter](https://ggplot2-book.org/maps.html) of *ggplot2: Elegant graphics for data analysis*.

    ```{r}
    #| layout-ncol: 2
    #| fig-width: 3
    #| message: false
    #| fig-alt: |
    #|   Two maps of the boundaries of New Zealand. In the first plot the aspect 
    #|   ratio is incorrect, in the second plot it is correct.

    nz <- map_data("nz")

    ggplot(nz, aes(x = long, y = lat, group = group)) +
      geom_polygon(fill = "white", color = "black")

    ggplot(nz, aes(x = long, y = lat, group = group)) +
      geom_polygon(fill = "white", color = "black") +
      coord_quickmap()
    ```

-   `coord_polar()` uses polar coordinates.
    Polar coordinates reveal an interesting connection between a bar chart and a Coxcomb chart.

    ```{r}
    #| layout-ncol: 2
    #| fig-width: 3
    #| fig-asp: 1
    #| fig-alt: |
    #|   There are two plots. On the left is a bar chart of clarity of diamonds, 
    #|   on the right is a Coxcomb chart of the same data.

    bar <- ggplot(data = diamonds) + 
      geom_bar(
        mapping = aes(x = clarity, fill = clarity), 
        show.legend = FALSE,
        width = 1
      ) + 
      theme(aspect.ratio = 1)

    bar + coord_flip()
    bar + coord_polar()
    ```

### Exercises

1.  Turn a stacked bar chart into a pie chart using `coord_polar()`.

2.  What's the difference between `coord_quickmap()` and `coord_map()`?

3.  What does the following plot tell you about the relationship between city and highway mpg?
    Why is `coord_fixed()` important?
    What does `geom_abline()` do?

    ```{r}
    #| fig-show: hide

    ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +
      geom_point() + 
      geom_abline() +
      coord_fixed()
    ```

## The layered grammar of graphics

We can expand on the graphing template you learned in @sec-ggplot2-calls by adding position adjustments, stats, coordinate systems, and faceting:

```         
ggplot(data = <DATA>) + 
  <GEOM_FUNCTION>(
     mapping = aes(<MAPPINGS>),
     stat = <STAT>, 
     position = <POSITION>
  ) +
  <COORDINATE_FUNCTION> +
  <FACET_FUNCTION>
```

Our new template takes seven parameters, the bracketed words that appear in the template.
In practice, you rarely need to supply all seven parameters to make a graph because ggplot2 will provide useful defaults for everything except the data, the mappings, and the geom function.

The seven parameters in the template compose the grammar of graphics, a formal system for building plots.
The grammar of graphics is based on the insight that you can uniquely describe *any* plot as a combination of a dataset, a geom, a set of mappings, a stat, a position adjustment, a coordinate system, a faceting scheme, and a theme.

To see how this works, consider how you could build a basic plot from scratch: you could start with a dataset and then transform it into the information that you want to display (with a stat).
Next, you could choose a geometric object to represent each observation in the transformed data.
You could then use the aesthetic properties of the geoms to represent variables in the data.
You would map the values of each variable to the levels of an aesthetic.
These steps are illustrated in @fig-visualization-grammar.
You'd then select a coordinate system to place the geoms into, using the location of the objects (which is itself an aesthetic property) to display the values of the x and y variables.

```{r}
#| label: fig-visualization-grammar
#| echo: false
#| fig-alt: |
#|   A figure demonstrating the steps for going from raw data to table of 
#|   frequencies where each row represents one level of cut and a count column 
#|   shows how many diamonds are in that cut level. Then, these values are 
#|   mapped to heights of bars.
#| fig-cap: |
#|   Steps for going from raw data to a table of frequencies to a bar plot where 
#|   the heights of the bar represent the frequencies.

knitr::include_graphics("images/visualization-grammar.png")
```

At this point, you would have a complete graph, but you could further adjust the positions of the geoms within the coordinate system (a position adjustment) or split the graph into subplots (faceting).
You could also extend the plot by adding one or more additional layers, where each additional layer uses a dataset, a geom, a set of mappings, a stat, and a position adjustment.

You could use this method to build *any* plot that you imagine.
In other words, you can use the code template that you've learned in this chapter to build hundreds of thousands of unique plots.

If you'd like to learn more about the theoretical underpinnings of ggplot2, you might enjoy reading "[The Layered Grammar of Graphics](https://vita.had.co.nz/papers/layered-grammar.pdf)", the scientific paper that describes the theory of ggplot2 in detail.

## Summary

In this chapter you learned about the layered grammar of graphics starting with aesthetics and geometries to build a simple plot, facets for splitting the plot into subsets, statistics for understanding how geoms are calculated, position adjustments for controlling the fine details of position when geoms might otherwise overlap, and coordinate systems which allow you to fundamentally change what `x` and `y` mean.
One layer we have not yet touched on is theme, which we will introduce in @sec-themes.

Two very useful resources for getting an overview of the complete ggplot2 functionality are the ggplot2 cheatsheet (which you can find at <https://posit.co/resources/cheatsheets>) and the ggplot2 package website ([https://ggplot2.tidyverse.org](https://ggplot2.tidyverse.org/)).

An important lesson you should take from this chapter is that when you feel the need for a geom that is not provided by ggplot2, it's always a good idea to look into whether someone else has already solved your problem by creating a ggplot2 extension package that offers that geom.
