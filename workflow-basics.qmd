# ワークフロー：基本 {#sec-workflow-basics}

```{r}
#| echo: false

source("_common.R")
```

ここまでで、Rコードを走らせる経験をいくらか積みました。
詳細は述べてきませんでしたが、基本は分かったはずです。で
なければ、不満を爆発させて本書を投げ捨ててしまっているでしょうから！
Rでプログラムをはじめる際に不満を覚えるのは自然なことです。R
はパンクチュエーションにとてもうるさく、一文字でも違っていると文句を垂れるのですから。
少々不満は覚えるでしょうが、その経験は典型的かつ一時的なものです。誰
にでも起きることですし、乗り越えるにはトライし続けるしかないのです。

先に進む前に、Rコードを走らせる基礎を固め、RStudioの最も役立つ機能を会得していることを確認しましょう。

## コーディングの基本

できるだけ速くプロットできるになってもらうため、ここまで省略してきた基本のいくつかを検討しましょう。
Rを使って、基礎的な数値計算が可能です。

```{r}
1 / 200 * 30
(59 + 73 + 2) / 3
sin(pi / 2)
```

代入子`<-`を使って、新しいオブジェクトを作れます。

```{r}
x <- 3 * 4
```

`x`の値はプリントされていませんね。た
だ保存されただけです。
値を見たければ、コンソールに`x`と打ち込みます。

複数の要素を一つのベクタにまとめるには、`c()`を使います。

```{r}
primes <- c(2, 3, 5, 7, 11, 13)
```

ベクタへの基礎的な算術は、ベクタの各要素に適用されます。

```{r}
primes * 2
primes - 1
```

オブジェクトを作るRの文、**代入**文、は全て同じ形式を取ります。

```{r}
#| eval: false

object_name <- value
```

このコードを読む際は、頭の中で"object nameがvalueを取る"と読みます。

しょっちゅう代入しますので、`<-`と打ち込むのは苦痛です。
RStudioではキーボード・ショートカット、Alt + - (マイナス・サイン) で済みます。
RStudioは、コード・フォーマットの良い慣例に従って、自動的に`<-`の両端にスペースを加えます。
素晴らし日に目に悪いコードを読むと、惨めな思いをします。ス
ペースを使って、目に優しいコードを書きましょう。

## コメント

Rは行に`#`があると、そこから後ろは無視します。
Rには無視されるが、人間には読めるので、コメントが書けるのです。
コードで何をしているのか説明するコメントを、例に含めることがあります。

コードが何をするのか簡略に述べるのに、コメントは役に立ちます。

```{r}
# create vector of primes
primes <- c(2, 3, 5, 7, 11, 13)

# multiply primes by 2
primes * 2
```

このような短いコードであれば、一行ずつコメントを付けることは不要でしょう。
しかし、コードが複雑になってくると、あなた (とあなたの共同作業者) がコードが何をしているのか見つけ出す時間を、コメントは大いに省けます。

コードの*いかに*や*何を*ではなく*なぜ*を説明するのに、コメントは使ってください。
コードの*いかに*や*何を*は、面倒かもしれませんが、注意深く読めば、必ず見つけ出すことが可能です。
全てのステップにコメントを付けてから、コードを変えると、コメントも忘れずにアップデートしないと、将来コードに戻って来たときに混乱してしまいます。

*なぜ*こうしているのか、は見つけ出すのが不可能でないとしてもずっと困難です。
例えば、`geom_smooth()`には`span`という引数があって、曲線の滑らかさをコントロールしていて、値を大きくするほど曲線は滑らかになります。
`span`の値をデフォルトの0.75から0.9に変更することにしたとします。将
来コードを読む人にとって、*何を*しているのか理解することは容易ですが、コメントを付けていないと、*なぜ*デフォルトから変更したのか理解することはできません。

データ分析のコードでは、取り組みの全体計画を説明し、重要な洞察に出会うたびにそれを記録するために、コメントを使いましょう。
コード自体からこの知識を再把握することはできないのですから。

## What's in a name? {#sec-whats-in-a-name}

Object names must start with a letter and can only contain letters, numbers, `_`, and `.`.
You want your object names to be descriptive, so you'll need to adopt a convention for multiple words.
We recommend **snake_case**, where you separate lowercase words with `_`.

```{r}
#| eval: false

i_use_snake_case
otherPeopleUseCamelCase
some.people.use.periods
And_aFew.People_RENOUNCEconvention
```

We'll return to names again when we discuss code style in @sec-workflow-style.

You can inspect an object by typing its name:

```{r}
x
```

Make another assignment:

```{r}
this_is_a_really_long_name <- 2.5
```

To inspect this object, try out RStudio's completion facility: type "this", press TAB, add characters until you have a unique prefix, then press return.

Let's assume you made a mistake, and that the value of `this_is_a_really_long_name` should be 3.5, not 2.5.
You can use another keyboard shortcut to help you fix it.
For example, you can press ↑ to bring the last command you typed and edit it.
Or, type "this" then press Cmd/Ctrl + ↑ to list all the commands you've typed that start with those letters.
Use the arrow keys to navigate, then press enter to retype the command.
Change 2.5 to 3.5 and rerun.

Make yet another assignment:

```{r}
r_rocks <- 2^3
```

Let's try to inspect it:

```{r}
#| eval: false

r_rock
#> Error: object 'r_rock' not found
R_rocks
#> Error: object 'R_rocks' not found
```

This illustrates the implied contract between you and R: R will do the tedious computations for you, but in exchange, you must be completely precise in your instructions.
If not, you're likely to get an error that says the object you're looking for was not found.
Typos matter; R can't read your mind and say, "oh, they probably meant `r_rocks` when they typed `r_rock`".
Case matters; similarly, R can't read your mind and say, "oh, they probably meant `r_rocks` when they typed `R_rocks`".

## Calling functions

R has a large collection of built-in functions that are called like this:

```{r}
#| eval: false

function_name(argument1 = value1, argument2 = value2, ...)
```

Let's try using `seq()`, which makes regular **seq**uences of numbers, and while we're at it, learn more helpful features of RStudio.
Type `se` and hit TAB.
A popup shows you possible completions.
Specify `seq()` by typing more (a `q`) to disambiguate or by using ↑/↓ arrows to select.
Notice the floating tooltip that pops up, reminding you of the function's arguments and purpose.
If you want more help, press F1 to get all the details in the help tab in the lower right pane.

When you've selected the function you want, press TAB again.
RStudio will add matching opening (`(`) and closing (`)`) parentheses for you.
Type the name of the first argument, `from`, and set it equal to `1`.
Then, type the name of the second argument, `to`, and set it equal to `10`.
Finally, hit return.

```{r}
seq(from = 1, to = 10)
```

We often omit the names of the first several arguments in function calls, so we can rewrite this as follows:

```{r}
seq(1, 10)
```

Type the following code and notice that RStudio provides similar assistance with the paired quotation marks:

```{r}
x <- "hello world"
```

Quotation marks and parentheses must always come in a pair.
RStudio does its best to help you, but it's still possible to mess up and end up with a mismatch.
If this happens, R will show you the continuation character "+":

```         
> x <- "hello
+
```

The `+` tells you that R is waiting for more input; it doesn't think you're done yet.
Usually, this means you've forgotten either a `"` or a `)`. Either add the missing pair, or press ESCAPE to abort the expression and try again.

Note that the environment tab in the upper right pane displays all of the objects that you've created:

```{r}
#| echo: false
#| fig-alt: |
#|   Environment tab of RStudio which shows r_rocks, this_is_a_really_long_name, 
#|   x, and y in the Global Environment.

knitr::include_graphics("screenshots/rstudio-env.png")
```

## Exercises

1.  Why does this code not work?

    ```{r}
    #| error: true

    my_variable <- 10
    my_varıable
    ```

    Look carefully!
    (This may seem like an exercise in pointlessness, but training your brain to notice even the tiniest difference will pay off when programming.)

2.  Tweak each of the following R commands so that they run correctly:

    ```{r}
    #| eval: false

    libary(todyverse)

    ggplot(dTA = mpg) + 
      geom_point(maping = aes(x = displ y = hwy)) +
      geom_smooth(method = "lm)
    ```

3.  Press Option + Shift + K / Alt + Shift + K.
    What happens?
    How can you get to the same place using the menus?

4.  Let's revisit an exercise from the @sec-ggsave.
    Run the following lines of code.
    Which of the two plots is saved as `mpg-plot.png`?
    Why?

    ```{r}
    #| eval: false

    my_bar_plot <- ggplot(mpg, aes(x = class)) +
      geom_bar()
    my_scatter_plot <- ggplot(mpg, aes(x = cty, y = hwy)) +
      geom_point()
    ggsave(filename = "mpg-plot.png", plot = my_bar_plot)
    ```

## Summary

Now that you've learned a little more about how R code works, and some tips to help you understand your code when you come back to it in the future.
In the next chapter, we'll continue your data science journey by teaching you about dplyr, the tidyverse package that helps you transform data, whether it's selecting important variables, filtering down to rows of interest, or computing summary statistics.
